<!DOCTYPE html>
<!--AUTOGENERATED FILE - DO NOT EDIT - SEE Makefile-->
<html lang="en" xml:lang="en" xmlns1="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8"/><title>WebCL WEBCL_html_sharing Extension Draft Specification</title><link rel="alternate" type="text/xml" href="extension.xml"/><link rel="stylesheet" type="text/css" href="../../resources/Khronos-WD.css"/></head><body><!--begin-logo--><div class="left"><a href="http://webcl.org/"><img alt="WebCL" height="72" src="../../resources/WebCL_logo.png" width="156"/></a></div><div class="right"><a href="http://khronos.org/"><img alt="Khronos" height="60" src="../../resources/KhronosGroup-3D.png" width="220"/></a></div><div style="clear: both;">Â </div><br/><!--end-logo--><h1>WebCL WEBCL_html_sharing Extension Draft Specification</h1><h2 class="no-toc">Name</h2><p>WEBCL_html_sharing</p><h2 class="no-toc">Contact</h2><p> <a href="https://www.khronos.org/webcl/public-mailing-list/">WebCL
  working group</a> (public_webcl 'at' khronos.org) </p><h2 class="no-toc">Contributors</h2><p>Steven Eliuk, Samsung Electronics,</p><p>Tomi Aarnio, Nokia Research,</p><p>Members of the WebCL working group.</p><h2 class="no-toc">Version</h2><p> Last modified date: November 20, 2013<br/>
          Revision: 1</p><h2 class="no-toc">Number</h2><p> WebCL extension #7</p><h2 class="no-toc">Dependencies</h2>
    <p> Written against the <a href="http://www.khronos.org/registry/webcl/specs/1.0/">WebCL API 1.0</a> specification. </p>
  <h2 class="no-toc">Overview</h2>
     <p>
      The HTML Resource Sharing extension makes it more convenient and
      potentially faster for applications to transfer image data from
      HTML Image / Canvas elements to WebCL memory objects, and
      vice versa.  The extension is enabled by
      calling <code>enableExtension("WEBCL_html_sharing")</code>, after
      which the application may call the functions specified below.
    </p>
    <p> When this extension is enabled: </p><ul><li>
	WebCLBuffer and WebCLImage can be initialized at construction time from an ImageData, Canvas, or Image Element. This does not create a binding of any kind between the WebCL memory object and the data source. The source pixel format is treated as 32-bit RGBA (8-bits per component) with non-premultiplied alpha, regardless of the source.  
      </li></ul>
  <h2 class="no-toc">IDL</h2><pre class="idl">
    partial interface WebCLContext {
       WebCLBuffer createBuffer(CLenum memFlags, ImageData srcPixels);
       WebCLBuffer createBuffer(CLenum memFlags, HTMLCanvasElement srcCanvas);
       WebCLBuffer createBuffer(CLenum memFlags, HTMLImageElement srcImage);
       WebCLImage createImage(CLenum memFlags, ImageData srcPixels);
       WebCLImage createImage(CLenum memFlags, HTMLCanvasElement srcCanvas);
       WebCLImage createImage(CLenum memFlags, HTMLImageElement srcImage);
    };
    
    partial interface WebCLCommandQueue {

    //////////////////////////////////////////////////////////////////////
    //
    // Writing to WebCLBuffer
    //
    
    void enqueueWriteBuffer(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    CLuint                                bufferOffset,
                    ImageData                             srcPixels,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteBuffer(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    CLuint                                bufferOffset,
                    HTMLCanvasElement                     srcCanvas,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteBuffer(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    CLuint                                bufferOffset,
                    HTMLImageElement                      srcImage,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteBufferRect(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      bufferOrigin,
                    sequence&lt;CLuint&gt;                      srcOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                bufferRowPitch,
                    ImageData                             srcPixels,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteBufferRect(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      bufferOrigin,
                    sequence&lt;CLuint&gt;                      srcOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                bufferRowPitch,
                    HTMLCanvasElement                     srcCanvas,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteBufferRect(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      bufferOrigin,
                    sequence&lt;CLuint&gt;                      srcOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                bufferRowPitch,
                    HTMLImageElement                      srcImage,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    //////////////////////////////////////////////////////////////////////
    //
    // Writing to WebCLImage
    //
    
    void enqueueWriteImage(
                    WebCLImage                            image,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      origin,
                    sequence&lt;CLuint&gt;                      region,
                    ImageData                             srcPixels,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteImage(
                    WebCLImage                            image,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      origin,
                    sequence&lt;CLuint&gt;                      region,
                    HTMLCanvasElement                     srcCanvas,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueWriteImage(
                    WebCLImage                            image,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      origin,
                    sequence&lt;CLuint&gt;                      region,
                    HTMLImageElement                      srcImage,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);


    //////////////////////////////////////////////////////////////////////
    //
    // Reading from WebCL
    //

    void enqueueReadBuffer(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingRead,
                    CLuint                                bufferOffset,
                    CLuint                                numBytes,
                    HTMLCanvasElement                     dstCanvas,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueReadBufferRect(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingRead,
                    sequence&lt;CLuint&gt;                      bufferOrigin,
                    sequence&lt;CLuint&gt;                      dstOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                bufferRowPitch,
                    HTMLCanvasElement                     dstCanvas,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);

    void enqueueReadImage(
                    WebCLImage                            image,
                    CLboolean                             blockingRead,
                    sequence&lt;CLuint&gt;                      origin,
                    sequence&lt;CLuint&gt;                      region,
                    HTMLCanvasElement                     dstCanvas,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList,
                    optional WebCLEvent?                  event);
    };
  </pre><h2 class="no-toc">New Functions</h2><dl class="methods"><dt class="idl-code">WebCLBuffer createBuffer(CLenum memFlags, ImageData srcPixels)</dt><dd>
      
      
      Creates a new WebCLBuffer with size equal to <code>srcPixels.data.length</code>.
      <dl class="exceptions">
	 <dt>Exceptions:</dt>
	 <li>`WEBCL_EXTENSION_NOT_ENABLED` -- if the `WEBCL_html_sharing` extension has not been enabled</li>
	 <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcPixels.data.length &gt; DEVICE_MAX_MEM_ALLOC_SIZE</code></li>
	 <li>`INVALID_HOST_PTR` -- if `srcPixels` has unknown length, or is otherwise not valid</li>
       </dl>
    </dd><dt class="idl-code">WebCLBuffer createBuffer(CLenum memFlags, HTMLCanvasElement srcCanvas)</dt><dd>
      
      
      Creates a new WebCLBuffer with size equal to <code>srcCanvas.getContext("2d").getImageData().data.length</code>.
      <dl class="exceptions">
	 <dt>Exceptions:</dt>
	 <li>`WEBCL_EXTENSION_NOT_ENABLED` -- if the `WEBCL_html_sharing` extension has not been enabled</li>
	 <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcCanvas.getContext("2d").getImageData().data.length &gt; DEVICE_MAX_MEM_ALLOC_SIZE</code></li>
	 <li>`INVALID_HOST_PTR` -- if `srcCanvas` has unknown lengths, or is otherwise not valid</li>
       </dl>
    </dd><dt class="idl-code">WebCLBuffer createBuffer(CLenum memFlags, HTMLImageElement srcImage)</dt><dd>
      
      
      Creates a new WebCLBuffer with size equal to <code>srcImage.width * srcImage.height * 4</code>.
      <dl class="exceptions">
	 <dt>Exceptions:</dt>
	 <li>`WEBCL_EXTENSION_NOT_ENABLED` -- if the `WEBCL_html_sharing` extension has not been enabled</li>
	 <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcImage.width * srcImage.height * 4 &gt; DEVICE_MAX_MEM_ALLOC_SIZE</code></li>
	 <li>`INVALID_HOST_PTR` -- if `srcImage` has unknown lengths, or is otherwise not valid</li>
       </dl>
    </dd><dt class="idl-code">WebCLImage createImage(CLenum memFlags, WebCLImageDescriptor descriptor, ImageData srcPixels)</dt><dd>
      
      
      
       A newly create WebCLImage will have <code>channelOrder</code> equal to <code>RGBA, channelType</code> equal to <code>UNORM_INT8</code>, and <code> width</code> and<code> height</code> equal to <code>srcPixels.width</code> and <code>srcPixels.height</code>. The <code>descriptor</code> can be used to specify the row pitch for storage.
       <dl class="exceptions">
	 <dt>Exceptions:</dt>
	 <li>`WEBCL_EXTENSION_NOT_ENABLED` -- if the `WEBCL_html_sharing` extension has not been enabled</li>
	 <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcPixels.width &gt; DEVICE_IMAGE2D_MAX_WIDTH</code></li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcPixels.height &gt; DEVICE_IMAGE2D_MAX_HEIGHT</code></li>
	 <li>`INVALID_HOST_PTR` -- if `srcPixels` has unknown dimensions, or is otherwise not valid</li>
	 <li>`INVALID_IMAGE_FORMAT_DESCRIPTOR` -- if `descriptor.channelOrder` or `descriptor.channelType` 
	 is not valid</li>
	 <li>`IMAGE_FORMAT_NOT_SUPPORTED` -- if the given combination
	 of `channelOrder` and `channelType` is not supported for `srcPixels`</li>
       </dl>
    </dd><dt class="idl-code">WebCLImage createImage(CLenum memFlags, WebCLImageDescriptor descriptor, HTMLCanvasElement srcCanvas)</dt><dd>
      
      
      
      A newly create WebCLImage will have <code>channelOrder</code> equal to <code>RGBA, channelType</code> equal to <code>UNORM_INT8</code>, and <code> width</code> and<code> height</code> equal to <code>srcCanvas.width</code> and <code>srcCanvas.height</code>. The <code>descriptor</code> can be used to specify the row pitch for storage.
       <dl class="exceptions">
	 <dt>Exceptions:</dt>
	 <li>`WEBCL_EXTENSION_NOT_ENABLED` -- if the `WEBCL_html_sharing` extension has not been enabled</li>
	 <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcCanvas.width &gt; DEVICE_IMAGE2D_MAX_WIDTH</code></li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcCanvas.height &gt; DEVICE_IMAGE2D_MAX_HEIGHT</code></li>
	 <li>`INVALID_HOST_PTR` -- if `srcCanvas` has unknown dimensions, or is otherwise not valid</li>
	 <li>`INVALID_IMAGE_FORMAT_DESCRIPTOR` -- if `descriptor.channelOrder` or `descriptor.channelType` 
	 is not valid</li>
	 <li>`IMAGE_FORMAT_NOT_SUPPORTED` -- if the given combination
	 of `channelOrder` and `channelType` is not supported for `srcPixels`</li>
       </dl>
    </dd><dt class="idl-code">WebCLImage createImage(CLenum memFlags, WebCLImageDescriptor descriptor, HTMLImageElement srcImage)</dt><dd>
      
      
      
      A newly create WebCLImage will have <code>channelOrder</code> equal to <code>RGBA, channelType</code> equal to <code>UNORM_INT8</code>, and <code> width</code> and<code> height</code> equal to <code>srcImage.width</code> and <code>srcImage.height</code>. The <code>descriptor</code> can be used to specify the row pitch for storage.
       <dl class="exceptions">
	 <dt>Exceptions:</dt>
	 <li>`WEBCL_EXTENSION_NOT_ENABLED` -- if the `WEBCL_html_sharing` extension has not been enabled</li>
	 <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcImage.width &gt; DEVICE_IMAGE2D_MAX_WIDTH</code></li>
	 <li>`INVALID_IMAGE_SIZE` -- if <code>srcImage.height &gt; DEVICE_IMAGE2D_MAX_HEIGHT</code></li>
	 <li>`INVALID_HOST_PTR` -- if `srcImage` has unknown dimensions, or is otherwise not valid</li>
	 <li>`INVALID_IMAGE_FORMAT_DESCRIPTOR` -- if `descriptor.channelOrder` or `descriptor.channelType` 
	 is not valid</li>
	 <li>`IMAGE_FORMAT_NOT_SUPPORTED` -- if the given combination
	 of `channelOrder` and `channelType` is not supported for `srcPixels`</li>
       </dl>
    </dd><dt class="idl-code">void enqueueWriteBuffer(WebCLBuffer buffer, CLboolean blockingWrite, CLuint bufferOffset, ImageData srcPixels, Optional sequence&lt;WebCLEvent&gt;? eventWaitList, Optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteBuffer(WebCLBuffer buffer, CLboolean blockingWrite, CLuint bufferOffset, HTMLCanvasElement srcCanvas, Optional sequence&lt;WebCLEvent&gt;? eventWaitList, Optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteBuffer(WebCLBuffer buffer, CLboolean blockingWrite, CLuint bufferOffset, HTMLImageElement srcImage, Optional sequence&lt;WebCLEvent&gt;? eventWaitList, Optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteBufferRect(WebCLBuffer buffer, CLboolean blockingWrite, sequence&lt;CLuint&gt; bufferOrigin, sequence&lt;CLuint&gt; srcOrigin, sequence&lt;CLuint&gt; region, CLuint bufferRowPitch, ImageData srcPixels, Optional sequence&lt;WebCLEvent&gt;? eventWaitList, Optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteBufferRect(WebCLBuffer buffer, CLboolean blockingWrite, sequence&lt;CLuint&gt; bufferOrigin, sequence&lt;CLuint&gt; srcOrigin, sequence&lt;CLuint&gt; region, CLuint bufferRowPitch, HTMLCanvasElement srcCanvas, Optional sequence&lt;WebCLEvent&gt;? eventWaitList, Optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteBufferRect(WebCLBuffer buffer, CLboolean blockingWrite, sequence&lt;CLuint&gt; bufferOrigin, sequence&lt;CLuint&gt; srcOrigin, sequence&lt;CLuint&gt; region, CLuint bufferRowPitch, HTMLImageElement srcImage, Optional sequence&lt;WebCLEvent&gt;? eventWaitList, Optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteImage(WebCLImage image, CLboolean blockingWrite, sequence&lt;CLuint&gt; origin, sequence&lt;CLuint&gt; region, ImageData srcPixels, optional sequence&lt;WebCLEvent&gt;? eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteImage(WebCLImage image, CLboolean blockingWrite, sequence&lt;CLuint&gt; origin, sequence&lt;CLuint&gt; region, ImageData srcPixels, optional sequence&lt;WebCLEvent&gt;? eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteImage(WebCLImage image, CLboolean blockingWrite, sequence&lt;CLuint&gt; origin, sequence&lt;CLuint&gt; region, HTMLCanvasElement srcCanvas, optional sequence&lt;WebCLEvent&gt;? eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueWriteImage(WebCLImage image, CLboolean blockingWrite, sequence&lt;CLuint&gt; origin, sequence&lt;CLuint&gt; region, HTMLImageElement srcImage, optional sequence&lt;WebCLEvent&gt;? eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueReadBuffer(WebCLBuffer buffer, CLboolean blockingRead, CLuint bufferOffset, CLuint numBytes, HTMLCanvasElement dstCanvas, optional sequence&lt;WebCLEvent&gt; eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueReadBufferRect(WebCLBuffer buffer, CLboolean blockingRead, sequence&gt;CLuint&gt; bufferOrigin, sequence&gt;CLuint&gt; dstOrigin, sequence&gt;CLuint&gt; region, CLuint bufferRowPitch, HTMLCanvasElement dstCanvas, optional sequence&lt;WebCLEvent&gt; eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
      
      
      
    </dd><dt class="idl-code">void enqueueReadImage(WebCLImage image, sequence&lt;CLuint&gt; origin, sequence&lt;CLuint&gt; region, HTMLCanvasElement dstCanvas, optional sequence&lt;WebCLEvent&gt; eventWaitList, optional WebCLEvent? event)</dt><dd>
      
      
      
      
      
      
    </dd></dl><h2 class="no-toc">Sample Code</h2>
    <pre class="example">
      
      var platforms = WebCL.getPlatforms();
      //no platforms
      if (platforms.length === 0) {
        return null;
      } 
      var platform = platforms[0];
      //if successful all device on platform have the extension enabled
      var isEnabledOnPlatform = platform.enableExtension("WEBCL_html_sharing");

      

      var devices = platform.getDevices();

      //no devices
      if (devices.length === 0) {
        return null;
      }
      var device = devices[0];
      //only this specific device would have the extension enabled.
      var isEnabledOnDevice = device.enableExtension("WEBCL_html_sharing");
    </pre>
  <h2 class="no-toc">Issues</h2>
    <ol>
      <li>
        <p>
         N/A
        </p>
      </li>
    </ol>
  <h2 class="no-toc">Revision History</h2><p>Revision 1, 2013/11/20</p><ul><li>Migrated from the WebCL Working Draft</li></ul></body></html>
