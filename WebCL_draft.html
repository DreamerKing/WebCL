<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>WebCL Specification</title>
    <link rel="stylesheet" type="text/css" href="./WebCL_draft_files/Khronos-draft.css">
    <script src="./WebCL_draft_files/jquery-1.3.2.min.js" type="text/javascript"></script>
    <script src="./WebCL_draft_files/generateTOC.js" type="text/javascript"></script>
</head>

<body onload="generateTOC(document.getElementById('toc'))">
    <!--begin-logo-->
    <div class="head">
        <p>
            <a href="http://khronos.org/">
                <img alt="Khronos" height="60" src="./WebCL_draft_files/KhronosGroup-3D.png" width="220">
            </a>
        </p>
    </div>
    <!--div class=head>
        <p>
            <a href="http://webcl.org/">
                <img alt=WebGL height=72 src="../../resources/WebCL-Logo.png" width=156>
            </a>
        </p>
    </div-->
    <!--end-logo-->
    
    <h1>WebCL Specification</h1>
    <dl>
        <dt>This version:
            <dd>
                <a href="https://www.khronos.org/registry/webcl/specs/latest/">
                    https://www.khronos.org/registry/webcl/specs/latest/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webcl/specs/latest/webcl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webcl/specs/latest/webcl.idl
                </a>
            </dd>
        <dt>Latest version:
            <dd>
                <a href="https://www.khronos.org/registry/webcl/specs/latest/">
                    https://www.khronos.org/registry/webcl/specs/latest/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webcl/specs/latest/webcl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webcl/specs/latest/webcl.idl
                </a>
            </dd>
        <dt>Previous version:
            <dd>
                <a href="https://www.khronos.org/registry/webcl/specs/1.0/">
                    https://www.khronos.org/registry/webcl/specs/1.0/
                </a>
                <br>
                <a href="https://www.khronos.org/registry/webcl/specs/1.0/webcl.idl">
                    <b>WebIDL:</b> https://www.khronos.org/registry/webcl/specs/1.0/webcl.idl
                </a>
            </dd>
        <dt>Editors:
            <dd>
                <a href="mailto:msevenier@motorola.com">Mikael Bourges-Sevenier</a>
                <a href="http://www.motorola.com/">(Motorola Mobility, Inc.)</a>
            </dd>
           <dd>
                <a href="mailto:tomi.aarnio@nokia.com">Tomi Aarnio</a>
                <a href="http://www.nokia.com/">(Nokia)</a>
            </dd>
    </dl>
    
    <span style="font-size: x-small; font-style: oblique">Copyright &copy; 2011 Khronos Group</span>

    <hr>
    
    <h2 class="no-toc">Abstract</h2>
    <p>
        This specification describes additional computing context objects for the HTML5 specification.
           
        This context allows computing using an API that conforms closely to the OpenCL 1.1 API.
        
        This specification has been modeled after OpenCL C++ object-oriented bindings. However, the method signatures
        have been changed based on the following considerations:
        <ul>
        <li>security reasons -- no pointer to memory area exposed</li>
        <li>familiar Javascript API design</li>
        <li>method overloading to reduce amount of methods</li>
        <li>methods creating objects attached to the object creating them instead of being
        a constructor of the created object</li>
        <li>exceptions are used instead of error codes. If an exception is thrown, then its argument contain the
        OpenCL error</li>
        <li>all objects are defined a unique module/package, that we call webcl in this document</li>
        <li>to avoid unnecessary data copy between ECMAScript and native layer, arrays are typed arrays. However, in some cases,
        typical ECMAScript arrays can also be used.</li>
        <li>All OpenCL constants are part of the webcl package, and with exactly the same values</li>
        <li>OpenCL Event and UserEvent classes are merged into WebCLEvent class.</li>
        </ul>
    </p>

    <h2 class="no-toc">Status of this document</h2>
    
    <!--begin-status-->
    <p>
        This document is an editor's draft. Do not cite this document as other than proposal and/or work in
        progress.  Public discussion of this specification is welcome on the
        (<a 
        href="https://www.khronos.org/webcl/public-mailing-list/archives/">archived</a>) WebCL
        mailing list <a href="mailto:public_webcl@khronos.org">public_webcl@khronos.org</a> (see
        <a href="http://www.khronos.org/webcl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->
    
    <h2 class="no-toc">History</h2>
    <ul>
		<li>2011-12-06 -- pushed document to Khronos CVS repo</li>
		<li>2011-12-01 -- added section about differences between WebCL and OpenCL 1.1</li>
		<li>2011-12-01 -- added extension mechanism modeled after WebGL, for WebGL-WebCL interop.</li>
		<li>2011-10-31 -- renamed getPlatformIDs to getPlatforms</li>
		<li>2011-10-27 -- following discussions: removed New() methods from all interfaces, removed [callback] from all interfaces. Updated example with kernel.setArg() types.</li>
		<li>2011-10-10 -- Motorola Mobility proposal, proposed to WebCL working group</li>
    </ul>
    <h2 class="no-toc">Table of contents</h2>
    <div id="toc"></div>

    <h2>Introduction</h2>

    <h2>Example</h2>
        <div class="example">
    Here is an ECMAScript example showing how to add 2 vectors.

    <pre>
function VectorAdd() {
  //First check if the WebCL extension is installed at all 
  if (WebCL == undefined) {
    alert("WebCL not supported.");
    return;
  }

  BUFFER_SIZE=10; // for example
  var A = new Uint32Array(BUFFER_SIZE);
  var B = new Uint32Array(BUFFER_SIZE);
  var C = new Uint32Array(BUFFER_SIZE);

  for (var i = 0; i < BUFFER_SIZE; i++) {
    A[i] = i;
    B[i] = i * 2;
    C[i] = 0;
  }

  //Pick platform
  var platformList=WebCL.getPlatforms();
  platform=platformList[0]; // select the first platform

  // create GPU context for this platform
  context = WebCL.createContext(WebCL.CL_DEVICE_TYPE_GPU, [WebCL.CL_CONTEXT_PLATFORM, platform]);

  //Query the set of devices attched to the context
  devices = context.getContextInfo(WebCL.CL_CONTEXT_DEVICES);

  kernelSource = [
"__kernel void                                                               ",
"vadd(__global int * a, __global int * b, __global int * c, int iNumElements)",
"{                                                                           ",
"    size_t i =  get_global_id(0);                                           ",
"    if(i > iNumElements) return;                                            ",
"    c[i] = a[i] + b[i];                                                     ",
"}                                                                           "
].join("\n");

  // Create and program from String source
  program = context.createProgram(kernelSource);

  // Build program
  program.build(devices); // note: no compilation flags given

  // Create device buffers
  size=BUFFER_SIZE * Uint32Array.BYTES_PER_ELEMENT; // size in bytes

  // Create buffer for A and copy host contents
  aBuffer = context.createBuffer(WebCL.CL_MEM_READ_ONLY, size);

  // Create buffer for B and copy host contents
  bBuffer = context.createBuffer(WebCL.CL_MEM_READ_ONLY, size);

  // Create buffer for that uses the host ptr C
  cBuffer = context.createBuffer(WebCL.CL_MEM_WRITE_ONLY, size);

  // Create kernel object
  kernel= program.createKernel("vadd");

  // Set kernel args
  kernel.setArg(0, aBuffer, WebCL.types.MEM);
  kernel.setArg(1, bBuffer, WebCL.types.MEM);
  kernel.setArg(2, cBuffer, WebCL.types.MEM);
  kernel.setArg(3, BUFFER_SIZE, WebCL.types.INT | WebCL.types.UNSIGNED);

  // Create command queue
  queue=context.createCommandQueue(devices[0], 0);

  // Init ND-range
  var localWS = [6];
  var globalWS = [Math.ceil (BUFFER_SIZE / localWS) * localWS];

  //log("Global work item size: " + globalWS);
  //log("Local work item size: " + localWS);

  // Execute (enqueue) kernel
  //log("using enqueueNDRangeKernel");
  queue.enqueueNDRangeKernel(kernel,
      [],
      [globalWS],
      [localWS]);
  
  // Do the work
  queue.enqueueWriteBuffer (aBuffer, false, { buffer: A, size: [A.length * Uint32Array.BYTES_PER_ELEMENT] });
  queue.enqueueWriteBuffer (bBuffer, false, { buffer: B, size: [B.length * Uint32Array.BYTES_PER_ELEMENT] });
  queue.enqueueReadBuffer  (cBuffer, false, { buffer: C, size: [C.length * Uint32Array.BYTES_PER_ELEMENT] });
  queue.finish (); //Finish all the operations
  
  // print results
}
    </pre>
    </div>
        <div class="example">
    Same example but with enqueueMapBuffer()/enqueueUnmapMemObject() instead of enqueueNDRange()

    <pre>

  //log("using enqueueMapBuffer");
  // Map cBuffer to host pointer. This enforces a sync with 
  // the host backing space, remember we choose GPU device.
  output=queue.enqueueMapBuffer(
      { buffer: cBuffer, size: [BUFFER_SIZE * Uint32Array.BYTES_PER_ELEMENT] },
      true, // block 
      WebCL.CL_MAP_READ);
  
  // print results
  
  queue.enqueueUnmapMemObject(
      cBuffer,
      output);
}
    </pre>
    </div>
    
<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <p>
        This section describes the interfaces and functionality added to the
        DOM to support runtime access to the functionality described above.
    </p>

<!-- ======================================================================================================= -->

    <h3>Types</h3>

    <p>
        The following types are used in interfaces in the following section.
        Memory objects, e.g. Buffer, Image2D, Image3D, are Typed Arrays. The type WebCLMemory derives
        from ArrayBuffer.
        ImageFormat object is an associative array with 2 keys, order and data_type.
    </p>
    <pre class="idl">interface WebCLMemory : ArrayBuffer {}
interface ImageFormat {
  order : int;
  data_type : int;
}
</pre>

    <p>
      OpenCL's enqueueMap/Unmap methods return memory mapped regions. For security reasons, such pointers are not returned to 
      the application. They are hidden within the WebCLMappedRegion object, defined as follows:
    </p>
    <pre class="idl">interface <dfn id="WebCLMappedRegion">WebCLMappedRegion</dfn> {
      ArrayBuffer buffer; // data in mapped region, may be Undefined
      WebCLEvent event;   // event that may be associated with this buffer, may be Undefined
};</pre>

    <p>
      Some OpenCL methods specify rectangular memory regions, as follows:
    </p>
    <pre class="idl">interface <dfn id="WebCLRegion">WebCLRegion</dfn> {
      ArrayBuffer buffer;         // buffer to be read or written
      int offset[1..3]={0,...,0}; // offset in bytes of the region in each dimension
      int slice_pitch = 0;        // pitch in bytes of a 2D slice
      int row_pitch = 0;          // pitch in bytes of a row
      int size[1..3]={1,...,1}    // size in bytes of the region
};</pre>
    <p>
      Notes:<br>
      <ul>
        <li>while we define two interfaces to deal with memory regions in this document, an implementation could choose
      to use only one interface merging these two interfaces.</li>
        <li>source and destination memory regions must have the same <code>size</code> vector.</li>
      </ul>
    </p>
<!-- ======================================================================================================= -->

    <h3><a name="WEBCL">WebCL</a></h3>

    <p>
        The <code>WebCL</code> interface contains general methods defined by OpenCL.
    </p>
    <pre class="idl">interface <dfn id="WebCL">WebCL</dfn> {
  WebCLPlatform[] getPlatforms();
  WebCLContext createContext(WebCLDevice devices[],int properties[]);
  WebCLContext createContext(int device_type, int properties[]);
  void waitForEvents(WebCLEvent events[]);
  void unloadCompiler();
};
</pre>

    <h4>Semantic</h4>

    <p>
        The following list describes each method in the WebCL object and its
        use. For each parameter the default value is shown. 
    </p>
    <dl class="methods">
        <dt class="idl-code">WebCLPlatform[] getPlatforms()</dt>
            <dd>                
            </dd>
        <dt class="idl-code">WebCLContext createContext(WebCLDevice devices[], int properties[])</dt>
            <dd>
            properties are defined as in OpenCL specification but there is no need to terminate the list by 0.
            This is an array of values in the form { &lt;parameter name&gt;, &lt;parameter value&gt; }.
            For example:
            [ webcl.CL_CONTEXT_PLATFORM, my_WebCLPlatform_object ]
            </dd>
        <dt class="idl-code">WebCLContext createContext(int device_type, int properties[])</dt>
            <dd>                
            </dd>
        <dt class="idl-code">void waitForEvents(WebCLEvent events[])</dt>
            <dd>                
            </dd>
        <dt class="idl-code">void unloadCompiler()</dt>
            <dd>                
            </dd>
    </dl>
<!-- ======================================================================================================= -->
    <h3><a name="WebCLCommandQueue">WebCLCommandQueue</a></h3>

    <p>
        The <code>WebCLCommandQueue</code> interface contain methods defined by OpenCL for CommandQueues.<br>
        Instead of using long list of arguments, as defined in OpenCL 1.1 specification, the following methods use the 
        associative array WebCLRegion to specify the area being read or written within an ArrayBuffer/WebCLMemory.
    </p>
    <pre class="idl">interface <dfn id="WebCLCommandQueue">WebCLCommandQueue</dfn> {
  Object getCommandQueueInfo(int name);
  
  WebCLEvent enqueueNDRangeKernel(WebCLKernel kernel[], 
    int offsets[1..3], int globals[1..3], int locals[1..3], 
    WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueTask(WebCLKernel kernel, WebCLEvent events[] = NULL);
  
  WebCLEvent enqueueWriteBuffer(WebCLMemory buffer, boolean blocking_write, 
    WebCLRegion array, WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueReadBuffer(WebCLMemory buffer, boolean blocking_read, 
    WebCLRegion array, WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueCopyBuffer(WebCLRegion src, WebCLRegion dst, WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueCopyImageToBuffer(WebCLRegion src_image, WebCLMemory dst_buffer, 
    WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueCopyBufferToImage(WebCLMemory src_buffer, WebCLRegion dst_image, 
    WebCLEvent event_wait_list[]=NULL);
  
  WebCLMappedRegion enqueueMapBuffer(WebCLRegion buffer, boolean blocking_map, cl_map map_flags, WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueUnmapMemObject(WebCLMemory memory, WebCLMappedRegion mapped_region, WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueMarker();
  
  WebCLEvent enqueueWaitForEvents(WebCLEvent event_wait_list[]);
  
  void enqueueBarrier();
  
  void finish();
  
  void flush();
    
  // WebGL interop. (this is a subset of OpenGL interop. extensions)
  WebCLEvent enqueueAcquireGLObjects(WebCLMemory objects[], WebCLEvent event_wait_list[]=NULL);
  
  WebCLEvent enqueueReleaseGLObjects(WebCLMemory objects[], WebCLEvent event_wait_list[]=NULL);
};</pre>

    <h4>Semantic</h4>

    <p>
        The following list describes each method in the WebCLCommandQueue object and its
        use. For each parameter the default value is shown.<br>
        <br>
        In the methods below, WebCLRegion is used to specify the memory region to be used. This allows to simplify the number
        of methods in WebCLCommandQueue object. Note also that for copy operations, source and host WebCLRegion must have the 
        same size field's values.
        
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getCommandQueueInfo(int name)</dt>
            <dd>     
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_QUEUE_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>CL_QUEUE_DEVICE</td><td>WebCLDevice</td></tr>
                <tr><td>CL_QUEUE_REFERENCE_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_QUEUE_PROPERTIES</td><td>Integer</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">WebCLEvent enqueueNDRangeKernel(WebCLKernel kernel[], int offsets[1..3], int globals[1..3], 
                                                            int locals[1..3], WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>     
            returns WebCLEvent
            Offsets, globals, locals contain 1, 2, or 3 NDRange values according to OpenCL C++ specification. However, OpenCL 1.1
            specification allows for up to CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS items.
            </dd>
        <dt class="idl-code">WebCLEvent enqueueTask(WebCLKernel kernel, WebCLEvent event_wait_list[] = NULL)</dt>
            <dd>     
            </dd>
        <dt class="idl-code">WebCLEvent enqueueWriteBuffer(WebCLMemory buffer, boolean blocking_write, 
        WebCLRegion array, WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>
              The WebCLRegion object contains the Array and offset in bytes being written.
            </dd>
        <dt class="idl-code">WebCLEvent enqueueReadBuffer(WebCLMemory buffer, boolean blocking_read, 
        WebCLRegion array, WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>     
            </dd>
        <dt class="idl-code">WebCLEvent enqueueCopyBuffer(WebCLRegion src, WebCLRegion dst, int size, 
        WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>     
            </dd>
        <dt class="idl-code">WebCLEvent enqueueCopyImageToBuffer(WebCLRegion src_image, WebCLMemory dst_buffer, 
        WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>     
            </dd>
        <dt class="idl-code">WebCLEvent enqueueCopyBufferToImage(WebCLMemory src_buffer, WebCLRegion dst_image, 
        WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>     
            </dd>
        <dt class="idl-code">WebCLMappedRegion enqueueMapBuffer(WebCLRegion buffer, boolean blocking_map, 
        int map_flags, WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>     
            </dd>
        <dt class="idl-code">WebCLEvent enqueueUnmapMemObject(WebCLMemory memory, WebCLMappedRegion mapped_region, 
        WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>
            mapped_region must be a WebCLMappedRegion returned by enqueueMapBuffer() or enqueueMapImage().
            </dd>
        <dt class="idl-code">WebCLEvent enqueueMarker()</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLEvent enqueueWaitForEvents(WebCLEvent event_wait_list[])</dt>
            <dd>
            </dd>
        <dt class="idl-code">void enqueueBarrier()</dt>
            <dd>
            </dd>
        <dt class="idl-code">void finish()</dt>
            <dd>
            </dd>
        <dt class="idl-code">void flush()</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLEvent enqueueAcquireGLObjects(WebCLMemory objects[], WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>
            acquire OpenCL memory objects that have been created from WebGL objects.
            </dd>
        <dt class="idl-code">WebCLEvent enqueueReleaseGLObjects(WebCLMemory objects[], WebCLEvent event_wait_list[]=NULL)</dt>
            <dd>
            release OpenCL memory objects that have been created from WebGL objects. These objects must be released before they can be used by OpenGL.
            </dd>
    </dl>
<!-- ======================================================================================================= -->
    <h3><a name="WebCLContext">WebCLContext</a></h3>

    <p>
        The <code>WebCLContext</code> interface contain methods defined by OpenCL for Context
    </p>
    <pre class="idl">interface <dfn id="WebCLContext">WebCLContext</dfn> {
  Object getContextInfo(int name);
  WebCLProgram createProgram(String source);
  WebCLCommandQueue createCommandQueue(WebCLDevice device, int properties[]);
  WebCLMemory createBuffer(int flags, int size);
  WebCLMemory createImage2D(int flags, ImageFormat format, int width, int height, int row_pitch);
  WebCLMemory createImage3D(int flags, ImageFormat format, int width, int height, int depth, int row_pitch, int slice_pitch);
  WebCLSampler createSampler(boolean normalized_coords, int addressing_mode, int filer_mode);
  ImageFormat[] getSupportedImageFormats(int flags, int image_type);
  WebCLEvent createUserEvent();
  
  // WebGL interop. (this is a subset of OpenGL interop. extensions)
  WebCLMemory createFromGLBuffer(int flags, WebGLBuffer buf);
  WebCLMemory createFromGLTexture(int flags, int miplevel, WebGLTexture texture);
  WebCLMemory createFromGLRenderBuffer(int flags, WebGLRenderBuffer buf);
  //WebCLMemory createFromGLSync(int sync); // TBD: GLsync object not defined in WebGL
};</pre>

    <h4>Semantic</h4>

    <p>
        The following list describes various methods in the WebCLContext object and its
        use. Default values for different parameters are shown below. 
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getContextInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_CONTEXT_REFERENCE_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_CONTEXT_NUM_DEVICES</td><td>Integer</td></tr>
                <tr><td>CL_CONTEXT_DEVICES</td><td>WebCLDevice[]</td></tr>
                <tr><td>CL_CONTEXT_PROPERTIES</td><td>Integer[]</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">WebCLProgram createProgram(String source)</dt>
            <dd>
            create a WebCLProgram from a UTF-8 string.
            </dd>
        <dt class="idl-code">WebCLProgram createProgram(ArrayBuffer binary)</dt>
            <dd>
            create a WebCLProgram from a binary source.
            </dd>
        <dt class="idl-code">WebCLCommandQueue createCommandQueue(WebCLDevice device, int properties[])</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLMemory createBuffer(int flags, int size)</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLMemory createImage2D(int flags, ImageFormat format, int width, int height, int row_pitch)</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLMemory createImage3D(int flags, ImageFormat format, int width, int height, int depth, int row_pitch, int slice_pitch)</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLSampler createSampler(boolean normalized_coords, int addressing_mode, int filer_mode)</dt>
            <dd>
            </dd>
        <dt class="idl-code">ImageFormat[] getSupportedImageFormats(int flags, int image_type)</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLEvent createUserEvent()</dt>
            <dd>
            </dd>
        <dt class="idl-code">WebCLMemory createFromGLBuffer(int flags, WebGLBuffer buf)</dt>
            <dd>
            Creates a CL Buffer from a WebGLBuffer. This function is only available if the context was created from a OpenGL context.
            </dd>
        <dt class="idl-code">WebCLMemory createFromGLTexture(int flags, int miplevel, WebGLTexture texture)</dt>
            <dd>
            Creates a CL Buffer from a WebGLTexture. This function is only available if the context was created from a OpenGL context. A 2D or 3D texture could be used
            even though WebGL 1.0 specification only allows for 2D textures currently.
            </dd>
        <dt class="idl-code">WebCLMemory createFromGLRenderBuffer(int flags, WebGLRenderBuffer buf)</dt>
            <dd>
            Creates a CL Buffer from a WebGLRenderBuffer. This function is only available if the context was created from a OpenGL context.
            </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a name="WebCLDevice">WebCLDevice</a></h3>

    <p>
        The <code>WebCLDevice</code> interface contain methods defined by OpenCL for Device
    </p>
    <pre class="idl">interface <dfn id="WebCLDevice">WebCLDevice</dfn> {
  Object getDeviceInfo(int name);
  Object getExtension(int name);
};</pre>

    <h4>Semantic</h4>
    <p>
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getDeviceInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_DEVICE_TYPE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_COMPUTE_UNITS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_WORK_ITEM_SIZES</td><td>Integer[3]</td></tr>
                <tr><td>CL_DEVICE_MAX_WORK_GROUP_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR<br>
                CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT<br>
                CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT<br>
                CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG<br>
                CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT<br>
                CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE<br>
                CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF<br>
                CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR<br>
                CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT<br>
                CL_DEVICE_NATIVE_VECTOR_WIDTH_INT<br>
                CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG<br>
                CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT<br>
                CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE<br>
                CL_DEVICE_NATIVE_ VECTOR_WIDTH_HALF
                </td><td>Integer</tr>
                <tr><td>CL_DEVICE_MAX_CLOCK_FREQUENCY</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_ADDRESS_BITS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_MEM_ALLOC_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_IMAGE_SUPPORT</td><td>Boolean</td></tr>
                <tr><td>CL_DEVICE_MAX_READ_IMAGE_ARGS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_WRITE_IMAGE_ARGS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_IMAGE2D_MAX_WIDTH<br>
                CL_DEVICE_IMAGE2D_MAX_HEIGHT <br>
                CL_DEVICE_IMAGE3D_MAX_WIDTH <br>
                CL_DEVICE_IMAGE3D_MAX_HEIGHT <br>
                CL_DEVICE_IMAGE3D_MAX_DEPTH
                </td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_SAMPLERS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_PARAMETER_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MEM_BASE_ADDR_ALIGN</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_SINGLE_FP_CONFIG</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_GLOBAL_MEM_CACHE_TYPE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_GLOBAL_MEM_CACHE_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_GLOBAL_MEM_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_MAX_CONSTANT_ARGS</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_LOCAL_MEM_TYPE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_LOCAL_MEM_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_ERROR_CORRECTION_SUPPORT</td><td>Boolean</td></tr>
                <tr><td>CL_DEVICE_HOST_UNIFIED_MEMORY</td><td>Boolean</td></tr>
                <tr><td>CL_DEVICE_PROFILING_TIMER_RESOLUTION</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_ENDIAN_LITTLE</td><td>Boolean</td></tr>
                <tr><td>CL_DEVICE_AVAILABLE</td><td>Boolean</td></tr>
                <tr><td>CL_DEVICE_COMPILER_AVAILABLE</td><td>Boolean</td></tr>
                <tr><td>CL_DEVICE_EXECUTION_CAPABILITIES</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_QUEUE_PROPERTIES</td><td>Integer</td></tr>
                <tr><td>CL_DEVICE_PLATFORM</td><td>WebCLPlatform</td></tr>
                <tr><td>CL_DEVICE_NAME<br>
                CL_DEVICE_VENDOR<br>
                CL_DRIVER_VERSION<br>
                CL_DEVICE_PROFILE
                </td><td>String</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">Object getExtension(int name)</dt>
            <dd>
            Returns an object if the passed extension is supported, or null if not. The object 
            returned from <code>getExtension</code> contains any constants or functions used by the 
            extension, if any. A returned object may have no constants or functions if the extension does 
            not define any, but a unique object must still be returned. That object is used to indicate 
            that the extension has been enabled. 
            </dd>
    </dl>
<!-- ======================================================================================================= -->
    <h3><a name="WebCLEvent">WebCLEvent</a></h3>

    <p>
        The <code>WebCLEvent</code> interface contain methods defined by OpenCL for Event
    </p>
    <pre class="idl">interface <dfn id="WebCLEvent">WebCLEvent</dfn> {
  Object getEventInfo(int name);
  Object getProfilingInfo(int name);
  void setUserEventStatus(int status);
};</pre>

    <h4>Semantic</h4>
    <p>
    Note: OpenCL's Event and UserEvent are merged into this WebCLEvent class.
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getEventInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_EVENT_COMMAND_QUEUE</td><td>WebCLCommandQueue</td></tr>
                <tr><td>CL_EVENT_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>CL_EVENT_COMMAND_TYPE</td><td>Integer</td></tr>
                <tr><td>CL_EVENT_COMMAND_EXECUTION_STATUS</td><td>Integer</td></tr>
                <tr><td>CL_EVENT_REFERENCE_COUNT</td><td>Integer</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">Object getProfilingInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_PROFILING_COMMAND_QUEUED</td><td>Integer</td></tr>
                <tr><td>CL_PROFILING_COMMAND_SUBMIT</td><td>Integer</td></tr>
                <tr><td>CL_PROFILING_COMMAND_START</td><td>Integer</td></tr>
                <tr><td>CL_PROFILING_COMMAND_END</td><td>Integer</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">void setUserEventStatus(int status)</dt>
            <dd>
            </dd>
    </dl>
<!-- ======================================================================================================= -->

    <h3><a name="WebCLKernel">WebCLKernel</a></h3>

    <p>
        The <code>WebCLKernel</code> interface contain methods defined by OpenCL for Kernel.
    </p>
    <pre class="idl">interface <dfn id="WebCLKernel">WebCLKernel</dfn> {
  Object getKernelInfo(int name);
  Object getWorkgroupInfo(int name);
  void setArg(int index, Object value, int type);
};</pre>

    <h4>Semantic</h4>
    <p>
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getKernelInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_KERNEL_FUNCTION_NAME</td><td>String</td></tr>
                <tr><td>CL_KERNEL_NUM_ARGS</td><td>Integer</td></tr>
                <tr><td>CL_KERNEL_REFERENCE_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_KERNEL_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>CL_KERNEL_PROGRAM</td><td>WebCLProgram</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">Object getWorkgroupInfo(int name)</dt>
            <dd>
            return an Integer or Integer[1..3] depending on the name queried.
            </dd>
        <dt class="idl-code">void setArg(int index, Object value, int type)</dt>
            <dd>
            Depending on the argument being set, the exact native data type of value cannot be infered from JavaScript. Likewise, it is not possible to know
            if an argument is __global or __local, without introspection of kernel method's code. To simplify programming, we propose a bitfield value called type
            that allows developers to specifity the data type of the argument. These types are defined in OpenCL 1.1 Specification, Table 6.1 (scalar types), 
            Table 6.2 (vector/array types), and Table 6.4 (reserved data types). Table 6.3 defines WebCLObjects data types such as image2D, image3D, sampler and event, which are all WebCLMemory objects or WebCLSampler
            or WebCLEvent respectively in this specification.<br><br>
            <table class="foo">
                <tr><th>webcl.type</th>       <th>Value</th>       <th>Description</th></tr>
                <tr><td>LOCAL</td>       	  <td>1<<0</td>        <td>__local or __global argument</td></tr>
                <tr><td>POINTER</td> 		  <td>1<<1</td>        <td>a pointer type</td></tr>
                <tr><td>UNSIGNED</td>      	  <td>1<<2</td>        <td>unsigned type</td></tr>
                <tr><td>MEM</td> 			  <td>1<<3</td>        <td>a WebCLMemory/WebCLSampler/WebCLEvent object</td></tr>
                <tr><td>COMPLEX</td>       <td>1<<4</td>        <td>a complex value</td></tr>
                <tr><td>IMAGINARY</td>     <td>1<<5</td>        <td>an imaginary value</td></tr>
                <tr><td>BOOL</td>             <td>1<<8</td>        <td>a boolean value</td></tr>
                <tr><td>CHAR</td>             <td>1<<9</td>        <td>an 8-bit integer value</td></tr>
                <tr><td>SHORT</td>            <td>1<<10</td>        <td>a 16-bit integer value</td></tr>
                <tr><td>INT</td>              <td>1<<11</td>        <td>a 32-bit integer value</td></tr>
                <tr><td>LONG</td>             <td>1<<12</td>        <td>a 64-bit integer value</td></tr>
                <tr><td>FLOAT</td>            <td>1<<13</td>        <td>a 32-bit IEEE 754 floating-point value</td></tr>
                <tr><td>HALF_FLOAT</td>       <td>1<<14</td>        <td>a 16-bit IEEE 754-2008 floating-point value</td></tr>
                <tr><td>DOUBLE</td>           <td>1<<15</td>        <td>a double-precision floating-point value</td></tr>
                <tr><td>QUAD</td>             <td>1<<16</td>        <td>a 128-bit floating-point value</td></tr>
                <tr><td>LONG_LONG</td>        <td>1<<17</td>        <td>a 128-bit integer value</td></tr>
                <tr><td>V2</td>                <td>1<<20</td>      <td>a 2-value vector</td></tr>
                <tr><td>V3</td>                <td>1<<21</td>      <td>a 3-value vector</td></tr>
                <tr><td>V4</td>                <td>1<<22</td>      <td>a 4-value vector</td></tr>
                <tr><td>V8</td>                <td>1<<23</td>      <td>a 8-value vector</td></tr>
                <tr><td>V16</td>               <td>1<<24</td>      <td>a 16-value vector</td></tr>
                <tr><td>M2xN</td>              <td>1<<25</td>     <td>a 2xn-value matrix</td></tr>
                <tr><td>M3xN</td>              <td>1<<26</td>     <td>a 3xn-value matrix</td></tr>
                <tr><td>M4xN</td>              <td>1<<27</td>     <td>a 4xn-value matrix</td></tr>
                <tr><td>M8xN</td>              <td>1<<28</td>     <td>a 8xn-value matrix</td></tr>
                <tr><td>M16xN</td>             <td>1<<29</td>    <td>a 16xn-value matrix</td></tr>
            </table><br>
            </dd>
    </dl>
<!-- ======================================================================================================= -->
    <h3><a name="WebCLMemory">WebCLMemory</a></h3>

    <p>
        The <code>WebCLMemory</code> interface contain methods defined by OpenCL for memory objects.
    </p>
    <pre class="idl">interface <dfn id="WebCLMemory">WebCLMemory</dfn> {
  Object getMemoryInfo(int name);
  Object getImageInfo(int name);
  WebCLMemory createSubBuffer(int flags, int type, Object region);
  WebGLObject getGLObjectInfo(int name);
  Object getGLTextureInfo(int name);
};</pre>

    <h4>Semantic</h4>
    <p>
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getMemoryInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_MEM_TYPE</td><td>Integer</td></tr>
                <tr><td>CL_MEM_FLAGS</td><td>Integer</td></tr>
                <tr><td>CL_MEM_SIZE</td><td>Integer</td></tr>
                <tr><td>CL_MEM_HOST_PTR</td><td>ArrayBuffer</td></tr>
                <tr><td>CL_MEM_MAP_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_MEM_REFERENCE_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_MEM_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>CL_MEM_ASSOCIATED_MEMOBJECT</td><td>WebCLMemory</td></tr>
                <tr><td>CL_MEM_OFFSET</td><td>Integer</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">Object getImageInfo(int name)</dt>
            <dd>
            return Integer, or ImageFormat depending on the name queried.
            </dd>
        <dt class="idl-code">WebCLMemory createSubBuffer(int flags, int type, Object region)</dt>
            <dd>
            The region object is an associative array { origin: int, size: int } and is only valid for CL_BUFFER_CREATE_TYPE_REGION type.
            </dd>
        <dt class="idl-code">WebGLObject getGLObjectInfo()</dt>
            <dd>
            Returns the WebGLObject that was used to create this OpenCL memory object.
            </dd>
        <dt class="idl-code">Object getGLTextureInfo(int name)</dt>
            <dd>
            Return the value for the passed name for an OpenCL memory object created from a WebGLTexture object. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_GL_TEXTURE_TARGET</td><td>Integer</td></tr>
                <tr><td>CL_GL_MIPMAP_LEVEL</td><td>Integer</td></tr>
            </table><br>
            </dd>
    </dl>
<!-- ======================================================================================================= -->
    <h3><a name="WebCLPlatform">WebCLPlatform</a></h3>

    <p>
        The <code>WebCLPlatform</code> interface contain methods defined by OpenCL for Platform.
    </p>
    <pre class="idl">interface <dfn id="WebCLPlatform">WebCLPlatform</dfn> {
  Object getPlatformInfo(int name);
  WebCLDevice[] getDevices(int device_type);
};</pre>

    <h4>Semantic</h4>
    <p>
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getPlatformInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_PLATFORM_PROFILE</td><td>String</td></tr>
                <tr><td>CL_PLATFORM_VERSION</td><td>String</td></tr>
                <tr><td>CL_PLATFORM_NAME</td><td>String</td></tr>
                <tr><td>CL_PLATFORM_VENDOR</td><td>String</td></tr>
                <tr><td>CL_PLATFORM_EXTENSIONS</td><td>String</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">WebCLDevice[] getDevices(int device_type)</dt>
            <dd>
            </dd>
    </dl>
<!-- ======================================================================================================= -->

    <h3><a name="WebCLProgram">WebCLProgram</a></h3>

    <p>
        The <code>WebCLProgram</code> interface contain methods defined by OpenCL for Program.
    </p>
    <pre class="idl">interface <dfn id="WebCLProgram">WebCLProgram</dfn> {
  Object getProgramInfo(int name);
  Object getBuildInfo(WebCLDevice device, int name);
  void build(WebCLDevice devices[], String options);
  WebCLKernel createKernel(String name);
};</pre>

    <h4>Semantic</h4>
    <p>
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getProgramInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_PROGRAM_REFERENCE_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_PROGRAM_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>CL_PROGRAM_NUM_DEVICES</td><td>Integer</td></tr>
                <tr><td>CL_PROGRAM_DEVICES</td><td>WebCLDevice</td></tr>
                <tr><td>CL_PROGRAM_SOURCE</td><td>String</td></tr>
                <tr><td>CL_PROGRAM_BINARY_SIZES</td><td>Integer[]</td></tr>
                <tr><td>CL_PROGRAM_BINARIES[]</td><td>ArrayBuffer[]</td></tr>
            </table><br>
            </dd>
        </dt>
        <dt class="idl-code">Object getBuildInfo(WebCLDevice device, int name)</dt>
            <dd>
            return Integer or String depending on name queried.
            </dd>
        </dt>
        <dt class="idl-code">void build(WebCLDevice devices[], String options = NULL)</dt>
            <dd>
            </dd>
        </dt>
        <dt class="idl-code">WebCLKernel createKernel(String name)</dt>
            <dd>
            </dd>
        </dt>
    </dl>
<!-- ======================================================================================================= -->

    <h3><a name="WebCLSampler">WebCLSampler</a></h3>

    <p>
        The <code>WebCLSampler</code> interface contain methods defined by OpenCL for Sampler.
    </p>
    <pre class="idl">interface <dfn id="WebCLSampler">WebCLSampler</dfn> {
  Object getSamplerInfo(int name);
};</pre>

    <h4>Semantic</h4>
    <p>
    </p>
    <dl class="methods">
        <dt class="idl-code">Object getSamplerInfo(int name)</dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>ECMAScript returned type</th></tr>
                <tr><td>CL_SAMPLER_REFERENCE_COUNT</td><td>Integer</td></tr>
                <tr><td>CL_SAMPLER_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>CL_SAMPLER_NORMALIZED_COORDS</td><td>Boolean</td></tr>
                <tr><td>CL_SAMPLER_ADDRESSING_MODE</td><td>Integer</td></tr>
                <tr><td>CL_SAMPLER_FILTER_MODE</td><td>Integer</td></tr>
            </table><br>
            </dd>
        </dt>
    </dl>
<!-- ======================================================================================================= -->

    <h3><a name="Constants">Constants</a></h3>

    <p>
    The constants identified below have the same values defined in the Open CL 1.1 specification, 
    including optional extensions.<br>
    Note: unless specified otherwise, prior to each section, a comment refers to the type these constants
    should be used for. For example, /* cl_platform_info */ means that the following constants are for this
    type only, which in turn is the name argument to 
    Platform.getPlatformInfo(name). Instead of listing such constants
    in the global webcl namespace, one could list them in the object the method using them belong; Platform in
    this example.
    </p>
    <pre class="idl">namespace <dfn id="Constants">webcl</dfn> {
/* Error Codes */
  CL_SUCCESS                                  =0;
  CL_DEVICE_NOT_FOUND                         =-1;
  CL_DEVICE_NOT_AVAILABLE                     =-2;
  CL_COMPILER_NOT_AVAILABLE                   =-3;
  CL_MEM_OBJECT_ALLOCATION_FAILURE            =-4;
  CL_OUT_OF_RESOURCES                         =-5;
  CL_OUT_OF_HOST_MEMORY                       =-6;
  CL_PROFILING_INFO_NOT_AVAILABLE             =-7;
  CL_MEM_COPY_OVERLAP                         =-8;
  CL_IMAGE_FORMAT_MISMATCH                    =-9;
  CL_IMAGE_FORMAT_NOT_SUPPORTED               =-10;
  CL_BUILD_PROGRAM_FAILURE                    =-11;
  CL_MAP_FAILURE                              =-12;
  CL_MISALIGNED_SUB_BUFFER_OFFSET             -13;
  CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST =-14;

  CL_INVALID_VALUE                            =-30;
  CL_INVALID_DEVICE_TYPE                      =-31;
  CL_INVALID_PLATFORM                         =-32;
  CL_INVALID_DEVICE                           =-33;
  CL_INVALID_CONTEXT                          =-34;
  CL_INVALID_QUEUE_PROPERTIES                 =-35;
  CL_INVALID_COMMAND_QUEUE                    =-36;
  CL_INVALID_HOST_PTR                         =-37;
  CL_INVALID_MEM_OBJECT                       =-38;
  CL_INVALID_IMAGE_FORMAT_DESCRIPTOR          =-39;
  CL_INVALID_IMAGE_SIZE                       =-40;
  CL_INVALID_SAMPLER                          =-41;
  CL_INVALID_BINARY                           =-42;
  CL_INVALID_BUILD_OPTIONS                    =-43;
  CL_INVALID_PROGRAM                          =-44;
  CL_INVALID_PROGRAM_EXECUTABLE               =-45;
  CL_INVALID_KERNEL_NAME                      =-46;
  CL_INVALID_KERNEL_DEFINITION                =-47;
  CL_INVALID_KERNEL                           =-48;
  CL_INVALID_ARG_INDEX                        =-49;
  CL_INVALID_ARG_VALUE                        =-50;
  CL_INVALID_ARG_SIZE                         =-51;
  CL_INVALID_KERNEL_ARGS                      =-52;
  CL_INVALID_WORK_DIMENSION                   =-53;
  CL_INVALID_WORK_GROUP_SIZE                  =-54;
  CL_INVALID_WORK_ITEM_SIZE                   =-55;
  CL_INVALID_GLOBAL_OFFSET                    =-56;
  CL_INVALID_EVENT_WAIT_LIST                  =-57;
  CL_INVALID_EVENT                            =-58;
  CL_INVALID_OPERATION                        =-59;
  CL_INVALID_GL_OBJECT                        =-60;
  CL_INVALID_BUFFER_SIZE                      =-61;
  CL_INVALID_MIP_LEVEL                        =-62;
  CL_INVALID_GLOBAL_WORK_SIZE                 =-63;
  CL_INVALID_PROPERTY                         =-64;

/* OpenCL Version */
  CL_VERSION_1_0                              =1;
  CL_VERSION_1_1                              =1;

/* cl_bool */
  CL_FALSE                                    =0;
  CL_TRUE                                     =1;

/* cl_platform_info */
  CL_PLATFORM_PROFILE                         =0x0900;
  CL_PLATFORM_VERSION                         =0x0901;
  CL_PLATFORM_NAME                            =0x0902;
  CL_PLATFORM_VENDOR                          =0x0903;
  CL_PLATFORM_EXTENSIONS                      =0x0904;

/* cl_device_type - bitfield */
  CL_DEVICE_TYPE_DEFAULT                      =(1 << 0);
  CL_DEVICE_TYPE_CPU                          =(1 << 1);
  CL_DEVICE_TYPE_GPU                          =(1 << 2);
  CL_DEVICE_TYPE_ACCELERATOR                  =(1 << 3);
  CL_DEVICE_TYPE_ALL                          =0xFFFFFFFF;

/* cl_device_info */
  CL_DEVICE_TYPE                              =0x1000;
  CL_DEVICE_VENDOR_ID                         =0x1001;
  CL_DEVICE_MAX_COMPUTE_UNITS                 =0x1002;
  CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS          =0x1003;
  CL_DEVICE_MAX_WORK_GROUP_SIZE               =0x1004;
  CL_DEVICE_MAX_WORK_ITEM_SIZES               =0x1005;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR       =0x1006;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT      =0x1007;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT        =0x1008;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG       =0x1009;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT      =0x100A;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE     =0x100B;
  CL_DEVICE_MAX_CLOCK_FREQUENCY               =0x100C;
  CL_DEVICE_ADDRESS_BITS                      =0x100D;
  CL_DEVICE_MAX_READ_IMAGE_ARGS               =0x100E;
  CL_DEVICE_MAX_WRITE_IMAGE_ARGS              =0x100F;
  CL_DEVICE_MAX_MEM_ALLOC_SIZE                =0x1010;
  CL_DEVICE_IMAGE2D_MAX_WIDTH                 =0x1011;
  CL_DEVICE_IMAGE2D_MAX_HEIGHT                =0x1012;
  CL_DEVICE_IMAGE3D_MAX_WIDTH                 =0x1013;
  CL_DEVICE_IMAGE3D_MAX_HEIGHT                =0x1014;
  CL_DEVICE_IMAGE3D_MAX_DEPTH                 =0x1015;
  CL_DEVICE_IMAGE_SUPPORT                     =0x1016;
  CL_DEVICE_MAX_PARAMETER_SIZE                =0x1017;
  CL_DEVICE_MAX_SAMPLERS                      =0x1018;
  CL_DEVICE_MEM_BASE_ADDR_ALIGN               =0x1019;
  CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE          =0x101A;
  CL_DEVICE_SINGLE_FP_CONFIG                  =0x101B;
  CL_DEVICE_GLOBAL_MEM_CACHE_TYPE             =0x101C;
  CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE         =0x101D;
  CL_DEVICE_GLOBAL_MEM_CACHE_SIZE             =0x101E;
  CL_DEVICE_GLOBAL_MEM_SIZE                   =0x101F;
  CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE          =0x1020;
  CL_DEVICE_MAX_CONSTANT_ARGS                 =0x1021;
  CL_DEVICE_LOCAL_MEM_TYPE                    =0x1022;
  CL_DEVICE_LOCAL_MEM_SIZE                    =0x1023;
  CL_DEVICE_ERROR_CORRECTION_SUPPORT          =0x1024;
  CL_DEVICE_PROFILING_TIMER_RESOLUTION        =0x1025;
  CL_DEVICE_ENDIAN_LITTLE                     =0x1026;
  CL_DEVICE_AVAILABLE                         =0x1027;
  CL_DEVICE_COMPILER_AVAILABLE                =0x1028;
  CL_DEVICE_EXECUTION_CAPABILITIES            =0x1029;
  CL_DEVICE_QUEUE_PROPERTIES                  =0x102A;
  CL_DEVICE_NAME                              =0x102B;
  CL_DEVICE_VENDOR                            =0x102C;
  CL_DRIVER_VERSION                           =0x102D;
  CL_DEVICE_PROFILE                           =0x102E;
  CL_DEVICE_VERSION                           =0x102F;
  CL_DEVICE_EXTENSIONS                        =0x1030;
  CL_DEVICE_PLATFORM                          =0x1031;
  CL_DEVICE_DOUBLE_FP_CONFIG                  =0x1032;
  CL_DEVICE_HALF_FP_CONFIG                    =0x1033;
  CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF       =0x1034;
  CL_DEVICE_HOST_UNIFIED_MEMORY               =0x1035;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR          =0x1036;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT         =0x1037;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_INT           =0x1038;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG          =0x1039;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT         =0x103A;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE        =0x103B;
  CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF          =0x103C;
  CL_DEVICE_OPENCL_C_VERSION                  =0x103D;

/* cl_device_fp_config - bitfield */
  CL_FP_DENORM                                =(1 << 0);
  CL_FP_INF_NAN                               =(1 << 1);
  CL_FP_ROUND_TO_NEAREST                      =(1 << 2);
  CL_FP_ROUND_TO_ZERO                         =(1 << 3);
  CL_FP_ROUND_TO_INF                          =(1 << 4);
  CL_FP_FMA                                   =(1 << 5);
  CL_FP_SOFT_FLOAT                            =(1 << 6);

/* cl_device_mem_cache_type */
  CL_NONE                                     =0x0;
  CL_READ_ONLY_CACHE                          =0x1;
  CL_READ_WRITE_CACHE                         =0x2;

/* cl_device_local_mem_type */
  CL_LOCAL                                    =0x1;
  CL_GLOBAL                                   =0x2;

/* cl_device_exec_capabilities - bitfield */
  CL_EXEC_KERNEL                              =(1 << 0);
  CL_EXEC_NATIVE_KERNEL                       =(1 << 1);

/* cl_command_queue_properties - bitfield */
  CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE      =(1 << 0);
  CL_QUEUE_PROFILING_ENABLE                   =(1 << 1);

/* cl_context_info  */
  CL_CONTEXT_REFERENCE_COUNT                  =0x1080;
  CL_CONTEXT_DEVICES                          =0x1081;
  CL_CONTEXT_PROPERTIES                       =0x1082;
  CL_CONTEXT_NUM_DEVICES                      =0x1083;

/* cl_context_info + cl_context_properties */
  CL_CONTEXT_PLATFORM                         =0x1084;

/* cl_command_queue_info */
  CL_QUEUE_CONTEXT                            =0x1090;
  CL_QUEUE_DEVICE                             =0x1091;
  CL_QUEUE_REFERENCE_COUNT                    =0x1092;
  CL_QUEUE_PROPERTIES                         =0x1093;

/* cl_mem_flags - bitfield */
  CL_MEM_READ_WRITE                           =(1 << 0);
  CL_MEM_WRITE_ONLY                           =(1 << 1);
  CL_MEM_READ_ONLY                            =(1 << 2);
  CL_MEM_USE_HOST_PTR                         =(1 << 3);
  CL_MEM_ALLOC_HOST_PTR                       =(1 << 4);
  CL_MEM_COPY_HOST_PTR                        =(1 << 5);

/* cl_channel_order */
  CL_R                                        =0x10B0;
  CL_A                                        =0x10B1;
  CL_RG                                       =0x10B2;
  CL_RA                                       =0x10B3;
  CL_RGB                                      =0x10B4;
  CL_RGBA                                     =0x10B5;
  CL_BGRA                                     =0x10B6;
  CL_ARGB                                     =0x10B7;
  CL_INTENSITY                                =0x10B8;
  CL_LUMINANCE                                =0x10B9;
  CL_Rx                                       =0x10BA;
  CL_RGx                                      =0x10BB;
  CL_RGBx                                     =0x10BC;

/* cl_channel_type */
  CL_SNORM_INT8                               =0x10D0;
  CL_SNORM_INT16                              =0x10D1;
  CL_UNORM_INT8                               =0x10D2;
  CL_UNORM_INT16                              =0x10D3;
  CL_UNORM_SHORT_565                          =0x10D4;
  CL_UNORM_SHORT_555                          =0x10D5;
  CL_UNORM_INT_101010                         =0x10D6;
  CL_SIGNED_INT8                              =0x10D7;
  CL_SIGNED_INT16                             =0x10D8;
  CL_SIGNED_INT32                             =0x10D9;
  CL_UNSIGNED_INT8                            =0x10DA;
  CL_UNSIGNED_INT16                           =0x10DB;
  CL_UNSIGNED_INT32                           =0x10DC;
  CL_HALF_FLOAT                               =0x10DD;
  CL_FLOAT                                    =0x10DE;

/* cl_mem_object_type */
  CL_MEM_OBJECT_BUFFER                        =0x10F0;
  CL_MEM_OBJECT_IMAGE2D                       =0x10F1;
  CL_MEM_OBJECT_IMAGE3D                       =0x10F2;

/* cl_mem_info */
  CL_MEM_TYPE                                 =0x1100;
  CL_MEM_FLAGS                                =0x1101;
  CL_MEM_SIZE                                 =0x1102;
  CL_MEM_HOST_PTR                             =0x1103;
  CL_MEM_MAP_COUNT                            =0x1104;
  CL_MEM_REFERENCE_COUNT                      =0x1105;
  CL_MEM_CONTEXT                              =0x1106;
  CL_MEM_ASSOCIATED_MEMOBJECT                 =0x1107;
  CL_MEM_OFFSET                               =0x1108;

/* cl_image_info */
  CL_IMAGE_FORMAT                             =0x1110;
  CL_IMAGE_ELEMENT_SIZE                       =0x1111;
  CL_IMAGE_ROW_PITCH                          =0x1112;
  CL_IMAGE_SLICE_PITCH                        =0x1113;
  CL_IMAGE_WIDTH                              =0x1114;
  CL_IMAGE_HEIGHT                             =0x1115;
  CL_IMAGE_DEPTH                              =0x1116;

/* cl_addressing_mode */
  CL_ADDRESS_NONE                             =0x1130;
  CL_ADDRESS_CLAMP_TO_EDGE                    =0x1131;
  CL_ADDRESS_CLAMP                            =0x1132;
  CL_ADDRESS_REPEAT                           =0x1133;
  CL_ADDRESS_MIRRORED_REPEAT                  =0x1134;

/* cl_filter_mode */
  CL_FILTER_NEAREST                           =0x1140;
  CL_FILTER_LINEAR                            =0x1141;

/* cl_sampler_info */
  CL_SAMPLER_REFERENCE_COUNT                  =0x1150;
  CL_SAMPLER_CONTEXT                          =0x1151;
  CL_SAMPLER_NORMALIZED_COORDS                =0x1152;
  CL_SAMPLER_ADDRESSING_MODE                  =0x1153;
  CL_SAMPLER_FILTER_MODE                      =0x1154;

/* cl_map_flags - bitfield */
  CL_MAP_READ                                 =(1 << 0);
  CL_MAP_WRITE                                =(1 << 1);

/* cl_program_info */
  CL_PROGRAM_REFERENCE_COUNT                  =0x1160;
  CL_PROGRAM_CONTEXT                          =0x1161;
  CL_PROGRAM_NUM_DEVICES                      =0x1162;
  CL_PROGRAM_DEVICES                          =0x1163;
  CL_PROGRAM_SOURCE                           =0x1164;
  CL_PROGRAM_BINARY_SIZES                     =0x1165;
  CL_PROGRAM_BINARIES                         =0x1166;

/* cl_program_build_info */
  CL_PROGRAM_BUILD_STATUS                     =0x1181;
  CL_PROGRAM_BUILD_OPTIONS                    =0x1182;
  CL_PROGRAM_BUILD_LOG                        =0x1183;

/* cl_build_status */
  CL_BUILD_SUCCESS                             =0;
  CL_BUILD_NONE                                =1;
  CL_BUILD_ERROR                              =-2;
  CL_BUILD_IN_PROGRESS                        =-3;

/* cl_kernel_info */
  CL_KERNEL_FUNCTION_NAME                     =0x1190;
  CL_KERNEL_NUM_ARGS                          =0x1191;
  CL_KERNEL_REFERENCE_COUNT                   =0x1192;
  CL_KERNEL_CONTEXT                           =0x1193;
  CL_KERNEL_PROGRAM                           =0x1194;

/* cl_kernel_work_group_info */
  CL_KERNEL_WORK_GROUP_SIZE                   =0x11B0;
  CL_KERNEL_COMPILE_WORK_GROUP_SIZE           =0x11B1;
  CL_KERNEL_LOCAL_MEM_SIZE                    =0x11B2;
  CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE =0x11B3;
  CL_KERNEL_PRIVATE_MEM_SIZE                  =0x11B4;

/* cl_event_info  */
  CL_EVENT_COMMAND_QUEUE                      =0x11D0;
  CL_EVENT_COMMAND_TYPE                       =0x11D1;
  CL_EVENT_REFERENCE_COUNT                    =0x11D2;
  CL_EVENT_COMMAND_EXECUTION_STATUS           =0x11D3;
  CL_EVENT_CONTEXT                            =0x11D4;

/* cl_command_type */
  CL_COMMAND_NDRANGE_KERNEL                   =0x11F0;
  CL_COMMAND_TASK                             =0x11F1;
  CL_COMMAND_NATIVE_KERNEL                    =0x11F2;
  CL_COMMAND_READ_BUFFER                      =0x11F3;
  CL_COMMAND_WRITE_BUFFER                     =0x11F4;
  CL_COMMAND_COPY_BUFFER                      =0x11F5;
  CL_COMMAND_READ_IMAGE                       =0x11F6;
  CL_COMMAND_WRITE_IMAGE                      =0x11F7;
  CL_COMMAND_COPY_IMAGE                       =0x11F8;
  CL_COMMAND_COPY_IMAGE_TO_BUFFER             =0x11F9;
  CL_COMMAND_COPY_BUFFER_TO_IMAGE             =0x11FA;
  CL_COMMAND_MAP_BUFFER                       =0x11FB;
  CL_COMMAND_MAP_IMAGE                        =0x11FC;
  CL_COMMAND_UNMAP_MEM_OBJECT                 =0x11FD;
  CL_COMMAND_MARKER                           =0x11FE;
  CL_COMMAND_ACQUIRE_GL_OBJECTS               =0x11FF;
  CL_COMMAND_RELEASE_GL_OBJECTS               =0x1200;
  CL_COMMAND_READ_BUFFER_RECT                 =0x1201;
  CL_COMMAND_WRITE_BUFFER_RECT                =0x1202;
  CL_COMMAND_COPY_BUFFER_RECT                 =0x1203;
  CL_COMMAND_USER                             =0x1204;

/* command execution status */
  CL_COMPLETE                                 =0x0;
  CL_RUNNING                                  =0x1;
  CL_SUBMITTED                                =0x2;
  CL_QUEUED                                   =0x3;
  
/* cl_buffer_create_type  */
  CL_BUFFER_CREATE_TYPE_REGION                =0x1220;

/* cl_profiling_info  */
  CL_PROFILING_COMMAND_QUEUED                 =0x1280;
  CL_PROFILING_COMMAND_SUBMIT                 =0x1281;
  CL_PROFILING_COMMAND_START                  =0x1282;
  CL_PROFILING_COMMAND_END                    =0x1283;

/*
 * cl_ext.h
 */
/* cl_khr_fp64 extension - no extension   since it has no functions  */
  CL_DEVICE_DOUBLE_FP_CONFIG                  =0x1032;

/* cl_khr_fp16 extension - no extension   since it has no functions  */
  CL_DEVICE_HALF_FP_CONFIG                    =0x1033;

/************************ 
* cl_khr_icd extension *                                                  
************************/
/* cl_platform_info                                                        */
  CL_PLATFORM_ICD_SUFFIX_KHR                  =0x0920;

/* Additional Error Codes                                                  */
  CL_PLATFORM_NOT_FOUND_KHR                   =-1001;

/******************************************
* cl_nv_device_attribute_query extension *
******************************************/
/* cl_nv_device_attribute_query extension - no extension   since it has no functions */
  CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV       =0x4000;
  CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV       =0x4001;
  CL_DEVICE_REGISTERS_PER_BLOCK_NV            =0x4002;
  CL_DEVICE_WARP_SIZE_NV                      =0x4003;
  CL_DEVICE_GPU_OVERLAP_NV                    =0x4004;
  CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV            =0x4005;
  CL_DEVICE_INTEGRATED_MEMORY_NV              =0x4006;

/*********************************
* cl_amd_device_attribute_query *
*********************************/
  CL_DEVICE_PROFILING_TIMER_OFFSET_AMD        =0x4036;

/* cl_device_partition_property_ext */
  CL_DEVICE_PARTITION_EQUALLY_EXT             =0x4050;
  CL_DEVICE_PARTITION_BY_COUNTS_EXT           =0x4051;
  CL_DEVICE_PARTITION_BY_NAMES_EXT            =0x4052;
  CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT  =0x4053;

/* clDeviceGetInfo selectors */
  CL_DEVICE_PARENT_DEVICE_EXT                 =0x4054;
  CL_DEVICE_PARTITION_TYPES_EXT               =0x4055;
  CL_DEVICE_AFFINITY_DOMAINS_EXT              =0x4056;
  CL_DEVICE_REFERENCE_COUNT_EXT               =0x4057;
  CL_DEVICE_PARTITION_STYLE_EXT               =0x4058;

/* error codes */
  CL_DEVICE_PARTITION_FAILED_EXT              =-1057;
  CL_INVALID_PARTITION_COUNT_EXT              =-1058;
  CL_INVALID_PARTITION_NAME_EXT               =-1059;

/* CL_AFFINITY_DOMAINs */
  CL_AFFINITY_DOMAIN_L1_CACHE_EXT             =0x1;
  CL_AFFINITY_DOMAIN_L2_CACHE_EXT             =0x2;
  CL_AFFINITY_DOMAIN_L3_CACHE_EXT             =0x3;
  CL_AFFINITY_DOMAIN_L4_CACHE_EXT             =0x4;
  CL_AFFINITY_DOMAIN_NUMA_EXT                 =0x10;
  CL_AFFINITY_DOMAIN_NEXT_FISSIONABLE_EXT     =0x100;

/* cl_device_partition_property_ext list terminators */
  CL_PROPERTIES_LIST_END_EXT                  =0;
  CL_PARTITION_BY_COUNTS_LIST_END_EXT         =0;
  CL_PARTITION_BY_NAMES_LIST_END_EXT          =-1;

/*********************************
* cl_amd_device_attribute_query *
*********************************/
/* cl_gl_object_type */
  CL_GL_OBJECT_BUFFER             =0x2000;
  CL_GL_OBJECT_TEXTURE2D          =0x2001;
  CL_GL_OBJECT_TEXTURE3D          =0x2002;
  CL_GL_OBJECT_RENDERBUFFER       =0x2003;

/* cl_gl_texture_info */
  CL_GL_TEXTURE_TARGET            =0x2004;
  CL_GL_MIPMAP_LEVEL              =0x2005;

/* Additional Error Codes  */
  CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR  =-1000;

/* cl_gl_context_info  */
  CL_CURRENT_DEVICE_FOR_GL_CONTEXT_KHR    =0x2006;
  CL_DEVICES_FOR_GL_CONTEXT_KHR           =0x2007;

/* Additional cl_context_properties  */
  CL_GL_CONTEXT_KHR                       =0x2008;
  CL_EGL_DISPLAY_KHR                      =0x2009;
  CL_GLX_DISPLAY_KHR                      =0x200A;
  CL_WGL_HDC_KHR                          =0x200B;
  CL_CGL_SHAREGROUP_KHR                   =0x200C;

/* 
 *  cl_khr_gl_event  extension
 *  See section 9.9 in the OpenCL 1.1 spec for more information
 */
  CL_COMMAND_GL_FENCE_SYNC_OBJECT_KHR     =0x200D;
};</pre>

<!-- ======================================================================================================= -->

    <h2>WebCL extensions</h2>
    <p>
        An implementation of WebCL must not support any additional parameters, constants or functions
        without first enabling that functionality through the extension mechanism. The 
        <code>WebCLDevice.getDeviceInfo(CL_DEVICE_EXTENSIONS)</code> function returns an array of the extension strings supported
        by this implementation. Extension strings are case-insensitive. An extension is enabled by 
        passing one of those strings to the <code>WebCLDevice.getExtension</code> function. This call returns an 
        object which contains any constants or functions defined by that extension. The definition of 
        that object is specific to the extension and must be defined by the extension specification.
    </p>
    <p>
        Once an extension is enabled, no mechanism is provided to disable it. Multiple calls to
        <code>WebCLDevice.getExtension</code> with the same extension string shall return the same object. An 
        attempt to use any features of an extension without first calling getExtension to enable it 
        must generate an appropriate CL exception and must not make use of the feature.
    </p>
    <p>
        This specification does not define any extensions. A separate 
        <a href="#refsREGISTRY">WebCL
        extension registry</a> defines extensions that may be supported 
        by a particular WebCL
        implementation.
    </p>
    
    <h2>Differences between WebCL and OpenCL 1.1</h2>
   <h2>References</h2>
    
    <h3>Normative references</h3>
    <dl>
    
        <dt id="refsOPENCL11">[OPENCL11]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf">
            The OpenCL Specification Version: 1.1</a></cite>,
            A. Munshi, June 2011.
        </dd>
        <dt id="refsTYPEDARRAYS">[TYPEDARRAYS]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/typedarray/specs/latest/">
            Typed Array Specification: Editor's Draft</a></cite>,
            V. Vukicevic, K. Russell, May 2010.
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsHTML">[HTML]</dt>
        <dd><cite><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">
            HTML</a></cite>,
            I. Hickson, June 2011.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL: W3C Editor’s Draft</a></cite>, 
            C. McCormack, September 2009.
        </dd>
        <dt id="refsASCII">[ASCII]</dt>
        <dd><cite>International Standard ISO/IEC 646:1991. Information technology - 
            ISO 7-bit coded character set for information interchange</cite>
        </dd>
        <dt id="refsDOMSTRING">[DOMSTRING]</dt>
        <dd><cite><a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#DOMString">
            Document Object Model Core: The DOMString type</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>
		<dt id="refsREGISTRY">[REGISTRY]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webcl/extensions/">
            WebCL Extension Registry</a></cite>
        </dd>    
    </dl>

    <h3>Other references</h3>

<!-- ======================================================================================================= -->
    
    <h2>Acknowledgments</h2>
    <p>
    <ul>
    <li>OpenCL group for their excellent <a 
    
    
    
    href="http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CCoQFjAA&url=http%3A%2F%2Fwww.khronos.org%2Fregistry%2Fcl%2Fspecs%2Fopencl-cplusplus-1.1.pdf&ei=PJDeTtjdFMWjiAKI6P3OCA&usg=AFQjCNG1eO7NFxYTiE4anLfsopuxkttqmg">C++ bindings</a>.</li>
    <li>Andreas Klöckner for <a 
    href="http://mathema.tician.de/software/pyopencl">pyOpenCL</a></li>
    <li>Samsung for their <a 
    href="http://code.google.com/p/webcl/">WebKit prototype</a></li>
    <li><a href="http://webcl.nokiaresearch.com/">Nokia WebCL</a> for their Firefox extension and libraries used in other projects such as 
    <a href="http://gfx.parapluie.org/2011/webcl-in-firefox">Fabien 
    Cellier's Firefox WebCL prototype</a> and <a 
    href="https://github.com/fifield/node-webcl">Jeff Fifield's 
    node-webcl</a>.</li>
    </ul>
    </p>
</body></html>
