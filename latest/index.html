<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>WebCL Working Draft</title>
  <link rel="stylesheet" type="text/css" href="./resources/Khronos-WD.css">
  <script src="./resources/jquery-1.3.2.min.js" type="text/javascript"></script>
  <script src="./resources/generateTOC.js" type="text/javascript"></script>
  <script src="./resources/generateHrefs.js" type="text/javascript"></script>
  <script type="text/javascript">

    function init() {

      // Generate a hyperlinked Table of Contents

      generateTOC(document.querySelector('#toc'));

      // Convert WebCL type names occurring in function signatures
      // into hyperlinks to the respective type definitions

      var typeDefs = $("dfn");
      var funcDefs = $("pre.idl, dt.idl-code");
      generateHrefs(typeDefs, funcDefs);

      // Replace inverse quotation marks with opening and
      // closing 'code' tags.  For example, `myVariable`
      // will be converted to <code>myVariable</code>.

      var regExp = new RegExp("\`[\\w\\s\\.\\-\\[\\]]*\`", "igm");
      var allText = $("p, dd, li");
      allText.each(function() {
        var matches = this.innerHTML.match(regExp);
        for (var i=0; matches && i < matches.length; i++) {
          var keyword = matches[i].substring(1, matches[i].length-1);
          var wrappedKeyword = "<code>"+keyword+"</code>";
          this.innerHTML = this.innerHTML.replace(matches[i], wrappedKeyword);
        }
      });
    }

  </script>
</head>

<body onload="init()">

    <!--begin-logo-->
    <div class="head">
        <p>
            <a href="http://khronos.org/">
                <img alt="Khronos" src="resources/KhronosGroup-3D.png" height="60" width="220">
            </a>
        </p>
    </div>
    <div class="head">
        <p>
            <a href="http://www.khronos.org/webcl">
                <img alt="WebCL logo" src="resources/WebCL_logo.png" width="150" height="69">
            </a>
        </p>
    </div>
    <!--end-logo-->

    <!-- begin warning box -->
    <div id="multipage-common">
      <p class="stability" id="wip">
        <strong>This is a work in progress!</strong>
        <input onclick="this.parentNode.parentNode.removeChild(this.parentNode)" type="button" value="x"/>
      </p>
    </div>
    <!-- end warning box -->

    <h1>WebCL Working Draft</h1>
    <h2 class="no-toc">January 17, 2013</h2>
    <dl>
      <dt>This version:
      </dt><dd>
        <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/index.html">
          https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/index.html
        </a><br>
          <b>WebIDL:</b>
          <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/webcl.idl">
          https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/webcl.idl
        </a>
      </dd>
      <dt>Latest version:
      </dt><dd>
        <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/index.html">
          https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/index.html
        </a><br>
          <b>WebIDL:</b>
          <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/webcl.idl">
          https://cvs.khronos.org/svn/repos/registry/trunk/public/webcl/spec/latest/webcl.idl
        </a>
      </dd>
      <dt>Previous version:
      </dt><dd>None</dd>
      <dt>Editors:</dt>
      <dd>
        <a href="mailto:tomi.aarnio@nokia.com">Tomi Aarnio</a>
        (<a href="http://webcl.nokiaresearch.com/">Nokia Research</a>)
      </dd>
      <dd>
        <a href="mailto:msevenier@motorola.com">Mika&euml;l Bourges-S&eacute;venier</a>
        (<a href="http://www.motorola.com/">Motorola Mobility, Inc.</a>)
      </dd>
	    <dt>Additional Contributors:</dt>
      <dd>
	      <a href="mailto:t.brutch@samsung.com">Tasneem Brutch</a>
        (<a href="http://www.samsung.com/">Samsung Electronics</a>) (Chair, WebCL WG)
      </dd>
      <dd>
	      <a href="mailto:s.gibbs@samsung.com">Simon Gibbs</a>
        (<a href="http://www.samsung.com/">Samsung Electronics</A>)
	    </dd>
    </dl>

    <p><span style="font-size: x-small; font-style: oblique">Copyright Â© 2013 Khronos Group</span></p>

    <hr>

    <h2 class="no-toc">Abstract</h2>
    <p>
      This Working Draft defines WebCL (Web Computing Language).
      WebCL is a JavaScript binding to the Khronos OpenCL standard for
      heterogeneous parallel computing. It enables web applications to
      harness GPU and multi-core CPU parallel processing from within a
      Web browser, enabling significant acceleration of
      computationally intensive applications, such as image and video
      processing and advanced physics for WebGL games.
    </p>

    <h2 class="no-toc">Status of this document</h2>

    <!--begin-status-->
    <p>
      This document is a Working Draft, not an official specification.
      Do not cite this document as anything other than work in
      progress.  Public discussion of this document is welcome on the
      (<a href="https://www.khronos.org/webcl/public-mailing-list/archives/">archived</a>)
      WebCL mailing
      list <a href="mailto:public_webcl@khronos.org">public_webcl@khronos.org</a>
      (see
      <a href="http://www.khronos.org/webcl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->

    <h2 class="no-toc">Contents</h2>
    <div id="toc"><ul class="toc">
    </ul></div>

<!-- ======================================================================================================= -->

    <h2>Introduction</h2>

    <p>
      TODO
    </p>

<!-- ======================================================================================================= -->

    <h2>DOM Interfaces</h2>

    <h3>Types</h3>

    <h4>Basic types</h4>

    <p>The following basic types are used in this document.</p>

<pre class="idl">
typedef boolean       CLboolean;
typedef long          CLint;
typedef unsigned long CLuint;
typedef long          CLenum;     // Used for enumerated types, such as WebCL.DEVICE_TYPE_GPU
typedef unsigned long CLtype;     // Used in WebCLKernelArgumentTypes
</pre>


    <h4><a id="WEBCLCALLBACK">Callbacks</a></h4>

    <p>
      WebCL allows certain long-running functions to be executed
      either synchronously or asynchronously. The asynchronous mode is
      used if a user-defined callback function is given as an argument
      to such functions. The signature of the callback is defined by
      WebCLCallback.
    </p>

<pre class="idl">
callback <dfn>WebCLCallback</dfn> = void (WebCLEvent event, any userdata);
</pre>

    <p>
      Any WebCL callback function can call arbitrary
      JavaScript functions, including both blocking and non-blocking
      APIs.  The following diagram is non-normative, but describes a
      possible implementation.
    </p>

    <img alt="callback" src="resources/callback.png" height="420" width="780"/>

    <h4><a id="WEBCLEXCEPTION">Exceptions</a></h4>

    <p>
      WebCL uses exceptions instead of returning error codes from
      functions. Both the type and message fields are present in any
      WebCLException thrown by the implementation, but the message may
      be null.
    </p>

<pre class="idl">
exception <dfn>WebCLException</dfn> : DOMException {
  DOMString name;              // A string representation of the numeric error code, e.g. "INVALID_VALUE"
  DOMString? message;          // An implementation-specific description of what caused the exception
};
</pre>

    <h3><a id="WEBCL">WebCL</a></h3>

      Window and WorkerUtils object MUST implement the WebCLEnvironment interface.

<pre class="idl">
Window implements <dfn>WebCLEnvironment</dfn>;
</pre>
<pre class="idl">
WorkerUtils implements <dfn>WebCLEnvironment</dfn>;
</pre>
<pre class="idl">
[NoInterfaceObject]
interface <dfn>WebCLEnvironment</dfn> {
    readonly attribute WebCL webcl;
};
</pre>
    <dl class="methods">

      <dt class="idl-code">webcl</dt>
      <dd>
        This attribute provides applications a mechanism for accessing WebCL compute capabilities.<p>
        <i>No exceptions.</i>
      </dd>
    </dl>

    <p>
      `WebCL` is a singleton object in the global namespace that can
      not be used as a constructor or invoked as a function.  It
      provides functions for creating computing contexts and for
      querying the available CL platforms and extensions. It also
      defines all enumerated types used in the API.
    </p>
<pre class="idl">
interface <dfn>WebCL</dfn> {

  // Functions

  sequence&lt;WebCLPlatform&gt; getPlatforms();

  WebCLContext? createContext(optional WebCLContextProperties properties);

  sequence&lt;DOMString&gt; getSupportedExtensions();

  void waitForEvents(WebCLEvent[] eventWaitList,
                     optional WebCLCallback whenFinished,
                     optional any userdata);

  // Enums

  /* Error Codes */
  CLenum SUCCESS                                   = 0;
  CLenum DEVICE_NOT_FOUND                          = -1;
  CLenum DEVICE_NOT_AVAILABLE                      = -2;
  CLenum COMPILER_NOT_AVAILABLE                    = -3;
  CLenum MEM_OBJECT_ALLOCATION_FAILURE             = -4;
  CLenum OUT_OF_RESOURCES                          = -5;
  CLenum OUT_OF_HOST_MEMORY                        = -6;
  CLenum PROFILING_INFO_NOT_AVAILABLE              = -7;
  CLenum MEM_COPY_OVERLAP                          = -8;
  CLenum IMAGE_FORMAT_MISMATCH                     = -9;
  CLenum IMAGE_FORMAT_NOT_SUPPORTED                = -10;
  CLenum BUILD_PROGRAM_FAILURE                     = -11;
  CLenum MAP_FAILURE                               = -12;
  CLenum MISALIGNED_SUB_BUFFER_OFFSET              = -13;
  CLenum EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14;
  CLenum INVALID_VALUE                             = -30;
  CLenum INVALID_DEVICE_TYPE                       = -31;
  CLenum INVALID_PLATFORM                          = -32;
  CLenum INVALID_DEVICE                            = -33;
  CLenum INVALID_CONTEXT                           = -34;
  CLenum INVALID_QUEUE_PROPERTIES                  = -35;
  CLenum INVALID_COMMAND_QUEUE                     = -36;
  CLenum INVALID_HOST_PTR                          = -37;
  CLenum INVALID_MEM_OBJECT                        = -38;
  CLenum INVALID_IMAGE_FORMAT_DESCRIPTOR           = -39;
  CLenum INVALID_IMAGE_SIZE                        = -40;
  CLenum INVALID_SAMPLER                           = -41;
  CLenum INVALID_BINARY                            = -42;
  CLenum INVALID_BUILD_OPTIONS                     = -43;
  CLenum INVALID_PROGRAM                           = -44;
  CLenum INVALID_PROGRAM_EXECUTABLE                = -45;
  CLenum INVALID_KERNEL_NAME                       = -46;
  CLenum INVALID_KERNEL_DEFINITION                 = -47;
  CLenum INVALID_KERNEL                            = -48;
  CLenum INVALID_ARG_INDEX                         = -49;
  CLenum INVALID_ARG_VALUE                         = -50;
  CLenum INVALID_ARG_SIZE                          = -51;
  CLenum INVALID_KERNEL_ARGS                       = -52;
  CLenum INVALID_WORK_DIMENSION                    = -53;
  CLenum INVALID_WORK_GROUP_SIZE                   = -54;
  CLenum INVALID_WORK_ITEM_SIZE                    = -55;
  CLenum INVALID_GLOBAL_OFFSET                     = -56;
  CLenum INVALID_EVENT_WAIT_LIST                   = -57;
  CLenum INVALID_EVENT                             = -58;
  CLenum INVALID_OPERATION                         = -59;
  CLenum INVALID_GL_OBJECT                         = -60;
  CLenum INVALID_BUFFER_SIZE                       = -61;
  CLenum INVALID_MIP_LEVEL                         = -62;
  CLenum INVALID_GLOBAL_WORK_SIZE                  = -63;
  CLenum INVALID_PROPERTY                          = -64;

  /* OpenCL Version */
  CLenum VERSION_1_0                               = 1;
  CLenum VERSION_1_1                               = 1;

  /* cl_bool */
  CLenum FALSE                                     = 0;
  CLenum TRUE                                      = 1;

  /* cl_platform_info */
  CLenum PLATFORM_PROFILE                          = 0x0900;
  CLenum PLATFORM_VERSION                          = 0x0901;
  CLenum PLATFORM_NAME                             = 0x0902;
  CLenum PLATFORM_VENDOR                           = 0x0903;
  CLenum PLATFORM_EXTENSIONS                       = 0x0904;

  /* cl_device_type - bitfield */
  CLenum DEVICE_TYPE_DEFAULT                       = 0x1;
  CLenum DEVICE_TYPE_CPU                           = 0x2;
  CLenum DEVICE_TYPE_GPU                           = 0x4;
  CLenum DEVICE_TYPE_ACCELERATOR                   = 0x8;
  CLenum DEVICE_TYPE_ALL                           = 0xFFFFFFFF;

  /* cl_device_info */
  CLenum DEVICE_TYPE                               = 0x1000;
  CLenum DEVICE_VENDOR_ID                          = 0x1001;
  CLenum DEVICE_MAX_COMPUTE_UNITS                  = 0x1002;
  CLenum DEVICE_MAX_WORK_ITEM_DIMENSIONS           = 0x1003;
  CLenum DEVICE_MAX_WORK_GROUP_SIZE                = 0x1004;
  CLenum DEVICE_MAX_WORK_ITEM_SIZES                = 0x1005;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_CHAR        = 0x1006;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_SHORT       = 0x1007;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_INT         = 0x1008;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_LONG        = 0x1009;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT       = 0x100A;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE      = 0x100B;
  CLenum DEVICE_MAX_CLOCK_FREQUENCY                = 0x100C;
  CLenum DEVICE_ADDRESS_BITS                       = 0x100D;
  CLenum DEVICE_MAX_READ_IMAGE_ARGS                = 0x100E;
  CLenum DEVICE_MAX_WRITE_IMAGE_ARGS               = 0x100F;
  CLenum DEVICE_MAX_MEM_ALLOC_SIZE                 = 0x1010;
  CLenum DEVICE_IMAGE2D_MAX_WIDTH                  = 0x1011;
  CLenum DEVICE_IMAGE2D_MAX_HEIGHT                 = 0x1012;
  CLenum DEVICE_IMAGE_SUPPORT                      = 0x1016;
  CLenum DEVICE_MAX_PARAMETER_SIZE                 = 0x1017;
  CLenum DEVICE_MAX_SAMPLERS                       = 0x1018;
  CLenum DEVICE_MEM_BASE_ADDR_ALIGN                = 0x1019;
  CLenum DEVICE_MIN_DATA_TYPE_ALIGN_SIZE           = 0x101A;
  CLenum DEVICE_SINGLE_FP_CONFIG                   = 0x101B;
  CLenum DEVICE_GLOBAL_MEM_CACHE_TYPE              = 0x101C;
  CLenum DEVICE_GLOBAL_MEM_CACHELINE_SIZE          = 0x101D;
  CLenum DEVICE_GLOBAL_MEM_CACHE_SIZE              = 0x101E;
  CLenum DEVICE_GLOBAL_MEM_SIZE                    = 0x101F;
  CLenum DEVICE_MAX_CONSTANT_BUFFER_SIZE           = 0x1020;
  CLenum DEVICE_MAX_CONSTANT_ARGS                  = 0x1021;
  CLenum DEVICE_LOCAL_MEM_TYPE                     = 0x1022;
  CLenum DEVICE_LOCAL_MEM_SIZE                     = 0x1023;
  CLenum DEVICE_ERROR_CORRECTION_SUPPORT           = 0x1024;
  CLenum DEVICE_PROFILING_TIMER_RESOLUTION         = 0x1025;
  CLenum DEVICE_ENDIAN_LITTLE                      = 0x1026;
  CLenum DEVICE_AVAILABLE                          = 0x1027;
  CLenum DEVICE_COMPILER_AVAILABLE                 = 0x1028;
  CLenum DEVICE_EXECUTION_CAPABILITIES             = 0x1029;
  CLenum DEVICE_QUEUE_PROPERTIES                   = 0x102A;
  CLenum DEVICE_NAME                               = 0x102B;
  CLenum DEVICE_VENDOR                             = 0x102C;
  CLenum DRIVER_VERSION                            = 0x102D;
  CLenum DEVICE_PROFILE                            = 0x102E;
  CLenum DEVICE_VERSION                            = 0x102F;
  CLenum DEVICE_EXTENSIONS                         = 0x1030;
  CLenum DEVICE_PLATFORM                           = 0x1031;
  CLenum DEVICE_DOUBLE_FP_CONFIG                   = 0x1032;
  CLenum DEVICE_HALF_FP_CONFIG                     = 0x1033;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_HALF        = 0x1034;
  CLenum DEVICE_HOST_UNIFIED_MEMORY                = 0x1035;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_CHAR           = 0x1036;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_SHORT          = 0x1037;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_INT            = 0x1038;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_LONG           = 0x1039;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_FLOAT          = 0x103A;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE         = 0x103B;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_HALF           = 0x103C;
  CLenum DEVICE_OPENCL_C_VERSION                   = 0x103D;

  /* cl_device_fp_config - bitfield */
  CLenum FP_DENORM                                 = 0x1;
  CLenum FP_INF_NAN                                = 0x2;
  CLenum FP_ROUND_TO_NEAREST                       = 0x4;
  CLenum FP_ROUND_TO_ZERO                          = 0x8;
  CLenum FP_ROUND_TO_INF                           = 0x10;
  CLenum FP_FMA                                    = 0x20;
  CLenum FP_SOFT_FLOAT                             = 0x40;

  /* cl_device_mem_cache_type */
  CLenum NONE                                      = 0x0;
  CLenum READ_ONLY_CACHE                           = 0x1;
  CLenum READ_WRITE_CACHE                          = 0x2;

  /* cl_device_local_mem_type */
  CLenum LOCAL                                     = 0x1;
  CLenum GLOBAL                                    = 0x2;

  /* cl_device_exec_capabilities - bitfield */
  CLenum EXEC_KERNEL                               = 0x1;
  CLenum EXEC_NATIVE_KERNEL                        = 0x2;

  /* cl_command_queue_properties - bitfield */
  CLenum QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE       = 0x1;
  CLenum QUEUE_PROFILING_ENABLE                    = 0x2;

  /* cl_context_info  */
  CLenum CONTEXT_REFERENCE_COUNT                   = 0x1080;
  CLenum CONTEXT_DEVICES                           = 0x1081;
  CLenum CONTEXT_PROPERTIES                        = 0x1082;
  CLenum CONTEXT_NUM_DEVICES                       = 0x1083;

  /* cl_context_info + cl_context_properties */
  CLenum CONTEXT_PLATFORM                          = 0x1084;

  /* cl_command_queue_info */
  CLenum QUEUE_CONTEXT                             = 0x1090;
  CLenum QUEUE_DEVICE                              = 0x1091;
  CLenum QUEUE_REFERENCE_COUNT                     = 0x1092;
  CLenum QUEUE_PROPERTIES                          = 0x1093;

  /* cl_mem_flags - bitfield */
  CLenum MEM_READ_WRITE                            = 0x1;
  CLenum MEM_WRITE_ONLY                            = 0x2;
  CLenum MEM_READ_ONLY                             = 0x4;

  /* cl_channel_order */
  CLenum R                                         = 0x10B0;
  CLenum A                                         = 0x10B1;
  CLenum RG                                        = 0x10B2;
  CLenum RA                                        = 0x10B3;
  CLenum RGB                                       = 0x10B4;
  CLenum RGBA                                      = 0x10B5;
  CLenum BGRA                                      = 0x10B6;
  CLenum ARGB                                      = 0x10B7;
  CLenum INTENSITY                                 = 0x10B8;
  CLenum LUMINANCE                                 = 0x10B9;
  CLenum Rx                                        = 0x10BA;
  CLenum RGx                                       = 0x10BB;
  CLenum RGBx                                      = 0x10BC;

  /* cl_channel_type */
  CLenum SNORM_INT8                                = 0x10D0;
  CLenum SNORM_INT16                               = 0x10D1;
  CLenum UNORM_INT8                                = 0x10D2;
  CLenum UNORM_INT16                               = 0x10D3;
  CLenum UNORM_SHORT_565                           = 0x10D4;
  CLenum UNORM_SHORT_555                           = 0x10D5;
  CLenum UNORM_INT_101010                          = 0x10D6;
  CLenum SIGNED_INT8                               = 0x10D7;
  CLenum SIGNED_INT16                              = 0x10D8;
  CLenum SIGNED_INT32                              = 0x10D9;
  CLenum UNSIGNED_INT8                             = 0x10DA;
  CLenum UNSIGNED_INT16                            = 0x10DB;
  CLenum UNSIGNED_INT32                            = 0x10DC;
  CLenum HALF_FLOAT                                = 0x10DD;
  CLenum FLOAT                                     = 0x10DE;

  /* cl_mem_object_type */
  CLenum MEM_OBJECT_BUFFER                         = 0x10F0;
  CLenum MEM_OBJECT_IMAGE2D                        = 0x10F1;

  /* cl_mem_info */
  CLenum MEM_TYPE                                  = 0x1100;
  CLenum MEM_FLAGS                                 = 0x1101;
  CLenum MEM_SIZE                                  = 0x1102;
  CLenum MEM_HOST_PTR                              = 0x1103;
  CLenum MEM_MAP_COUNT                             = 0x1104;
  CLenum MEM_REFERENCE_COUNT                       = 0x1105;
  CLenum MEM_CONTEXT                               = 0x1106;
  CLenum MEM_ASSOCIATED_MEMOBJECT                  = 0x1107;
  CLenum MEM_OFFSET                                = 0x1108;

  /* cl_image_info */
  CLenum IMAGE_FORMAT                              = 0x1110;
  CLenum IMAGE_ELEMENT_SIZE                        = 0x1111;
  CLenum IMAGE_ROW_PITCH                           = 0x1112;
  CLenum IMAGE_WIDTH                               = 0x1114;
  CLenum IMAGE_HEIGHT                              = 0x1115;

  /* cl_addressing_mode */
  CLenum ADDRESS_NONE                              = 0x1130;
  CLenum ADDRESS_CLAMP_TO_EDGE                     = 0x1131;
  CLenum ADDRESS_CLAMP                             = 0x1132;
  CLenum ADDRESS_REPEAT                            = 0x1133;
  CLenum ADDRESS_MIRRORED_REPEAT                   = 0x1134;

  /* cl_filter_mode */
  CLenum FILTER_NEAREST                            = 0x1140;
  CLenum FILTER_LINEAR                             = 0x1141;

  /* cl_sampler_info */
  CLenum SAMPLER_REFERENCE_COUNT                   = 0x1150;
  CLenum SAMPLER_CONTEXT                           = 0x1151;
  CLenum SAMPLER_NORMALIZED_COORDS                 = 0x1152;
  CLenum SAMPLER_ADDRESSING_MODE                   = 0x1153;
  CLenum SAMPLER_FILTER_MODE                       = 0x1154;

  /* cl_map_flags - bitfield */
  CLenum MAP_READ                                  = 0x1;
  CLenum MAP_WRITE                                 = 0x2;

  /* cl_program_info */
  CLenum PROGRAM_REFERENCE_COUNT                   = 0x1160;
  CLenum PROGRAM_CONTEXT                           = 0x1161;
  CLenum PROGRAM_NUM_DEVICES                       = 0x1162;
  CLenum PROGRAM_DEVICES                           = 0x1163;
  CLenum PROGRAM_SOURCE                            = 0x1164;
  CLenum PROGRAM_BINARY_SIZES                      = 0x1165;
  CLenum PROGRAM_BINARIES                          = 0x1166;

  /* cl_program_build_info */
  CLenum PROGRAM_BUILD_STATUS                      = 0x1181;
  CLenum PROGRAM_BUILD_OPTIONS                     = 0x1182;
  CLenum PROGRAM_BUILD_LOG                         = 0x1183;

  /* cl_build_status */
  CLenum BUILD_SUCCESS                             = 0;
  CLenum BUILD_NONE                                = 1;
  CLenum BUILD_ERROR                               = -2;
  CLenum BUILD_IN_PROGRESS                         = -3;

  /* cl_kernel_info */
  CLenum KERNEL_FUNCTION_NAME                      = 0x1190;
  CLenum KERNEL_NUM_ARGS                           = 0x1191;
  CLenum KERNEL_REFERENCE_COUNT                    = 0x1192;
  CLenum KERNEL_CONTEXT                            = 0x1193;
  CLenum KERNEL_PROGRAM                            = 0x1194;

  /* cl_kernel_work_group_info */
  CLenum KERNEL_WORK_GROUP_SIZE                    = 0x11B0;
  CLenum KERNEL_COMPILE_WORK_GROUP_SIZE            = 0x11B1;
  CLenum KERNEL_LOCAL_MEM_SIZE                     = 0x11B2;
  CLenum KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = 0x11B3;
  CLenum KERNEL_PRIVATE_MEM_SIZE                   = 0x11B4;

  /* cl_event_info  */
  CLenum EVENT_COMMAND_QUEUE                       = 0x11D0;
  CLenum EVENT_COMMAND_TYPE                        = 0x11D1;
  CLenum EVENT_REFERENCE_COUNT                     = 0x11D2;
  CLenum EVENT_COMMAND_EXECUTION_STATUS            = 0x11D3;
  CLenum EVENT_CONTEXT                             = 0x11D4;

  /* cl_command_type */
  CLenum COMMAND_NDRANGE_KERNEL                    = 0x11F0;
  CLenum COMMAND_TASK                              = 0x11F1;
  CLenum COMMAND_NATIVE_KERNEL                     = 0x11F2;
  CLenum COMMAND_READ_BUFFER                       = 0x11F3;
  CLenum COMMAND_WRITE_BUFFER                      = 0x11F4;
  CLenum COMMAND_COPY_BUFFER                       = 0x11F5;
  CLenum COMMAND_READ_IMAGE                        = 0x11F6;
  CLenum COMMAND_WRITE_IMAGE                       = 0x11F7;
  CLenum COMMAND_COPY_IMAGE                        = 0x11F8;
  CLenum COMMAND_COPY_IMAGE_TO_BUFFER              = 0x11F9;
  CLenum COMMAND_COPY_BUFFER_TO_IMAGE              = 0x11FA;
  CLenum COMMAND_MAP_BUFFER                        = 0x11FB;
  CLenum COMMAND_MAP_IMAGE                         = 0x11FC;
  CLenum COMMAND_UNMAP_MEM_OBJECT                  = 0x11FD;
  CLenum COMMAND_MARKER                            = 0x11FE;
  CLenum COMMAND_ACQUIRE_GL_OBJECTS                = 0x11FF;
  CLenum COMMAND_RELEASE_GL_OBJECTS                = 0x1200;
  CLenum COMMAND_READ_BUFFER_RECT                  = 0x1201;
  CLenum COMMAND_WRITE_BUFFER_RECT                 = 0x1202;
  CLenum COMMAND_COPY_BUFFER_RECT                  = 0x1203;
  CLenum COMMAND_USER                              = 0x1204;

  /* command execution status */
  CLenum COMPLETE                                  = 0x0;
  CLenum RUNNING                                   = 0x1;
  CLenum SUBMITTED                                 = 0x2;
  CLenum QUEUED                                    = 0x3;

  /* cl_buffer_create_type  */
  CLenum BUFFER_CREATE_TYPE_REGION                 = 0x1220;

  /* cl_profiling_info  */
  CLenum PROFILING_COMMAND_QUEUED                  = 0x1280;
  CLenum PROFILING_COMMAND_SUBMIT                  = 0x1281;
  CLenum PROFILING_COMMAND_START                   = 0x1282;
  CLenum PROFILING_COMMAND_END                     = 0x1283;

  /* cl_gl_object_type */
  CLenum GL_OBJECT_BUFFER                          = 0x2000;
  CLenum GL_OBJECT_TEXTURE2D                       = 0x2001;
  CLenum GL_OBJECT_RENDERBUFFER                    = 0x2003;

  /* cl_gl_texture_info */
  CLenum GL_TEXTURE_TARGET                         = 0x2004;
  CLenum GL_MIPMAP_LEVEL                           = 0x2005;
};
</pre>

    <dl class="methods">

      <dt class="idl-code">sequence&lt;WebCLPlatform&gt; getPlatforms()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=32">OpenCL 1.1 Â§4.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformIDs.html">man page</a>)</span>
      </dt>
      <dd>
        Retrieves all WebCL platforms that are available in this system.
      </dd>

       <dt class="idl-code">WebCLContext? createContext(optional WebCLContextProperties properties)
          <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=45">OpenCL 1.1 Â§4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateContext.html">man page</a>)</span>
         </dt>
      <dd>
        Returns a newly created WebCL context with the given
        properties, or `null` if a suitable context could not be
        created.  The `properties` parameter can be omitted, in which
        case the implementation will decide which platform and device
        (or devices) to use.  The WebCLContextProperties dictionary is
        defined as follows:

<pre class="idl" id="WEBCLCONTEXTPROPERTIES">
dictionary <dfn>WebCLContextProperties</dfn> {
  WebCLPlatform?  platform = null;      // Default: let the implementation decide
  WebCLDevice[]?  devices = null;       // Default: let the implementation decide
  CLenum          deviceType = 0x1;     // 0x1 == WebCL.DEVICE_TYPE_DEFAULT
  any             shareGroup = null;    // can only be a WebGL context
  DOMString[]?    hints = null;         // 'audio', 'video'
};
</pre>

    <dl class="methods">

      <dt class="idl-code">WebCLPlatform platform</dt>
      <dd>
        The platform to create a context for. If this is `null`, the
        implementation will decide which platform to use. Note that in
        typical systems, there is only one WebCLPlatform.
      </dd>

      <dt class="idl-code">WebCLDevice[] devices</dt>
      <dd>
        An array of devices to create the context for. The array must
        not be empty, and must not contain elements of any other type
        than WebCLDevice. The devices must be on the same platform,
        and if the `platform` field is non-`null`, the devices must be
        on that particular WebCLPlatform.
      </dd>

      <dt class="idl-code">CLenum deviceType</dt>
      <dd>
        The type of device to create a context for. The available
        device types are specified in the table below.  This field is
        ignored if `devices` is non-`null`.  If there is no device of
        the given type in the system or on the given `platform`,
        `createContext` will return `null`.  If `platform` and
        `devices` are both `null`, the WebCL implementation will
        select any platform that has one or more devices of the
        given type, and creates a context that spans all of those
        devices.

        <table class="foo">
          <tr><th>deviceType</th><th>Description</th></tr>
          <tr><td>DEVICE_TYPE_CPU</td><td>A single-core or multi-core CPU, typically the host processor.</td></tr>
          <tr><td>DEVICE_TYPE_GPU</td><td>A graphics processing unit, typically also used by WebGL.</td></tr>
          <tr><td>DEVICE_TYPE_ACCELERATOR</td><td>A dedicated OpenCL accelerator.</td></tr>
          <tr><td>DEVICE_TYPE_DEFAULT</td><td>The default device on this platform.</td></tr>
          <tr><td>DEVICE_TYPE_ALL</td><td>All devices available on this platform.</td></tr>
        </table>

      </dd>
      <dt class="idl-code">any shareGroup</dt>
      <dd>
      An array of resources to be shared with the newly created
      WebCLContext.  Currently, resource sharing is only supported
      with WebGL.  If resources are to be shared between WebGL and
      WebCL, `shareGroup` must contain the WebGLRenderingContext
      instance whose resources are to be shared.
      </dd>
      <dt class="idl-code">DOMString[] hints</dt>
      <dd>
      An optional array of hints to allow the implementation to find an appropriate
      WebCLContext suitable for audio-visual content. There is no guarantee implementations
      support these hints.
      </dd>
      </dl>

      <dt class="idl-code">sequence&lt;DOMString&gt; getSupportedExtensions()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-9">OpenCL 1.1 Â§9</a>)</span>
      </dt>
      <dd>
        Returns an array of extension names that are supported by all
        WebCLPlatforms and WebCLDevices in this implementation.  Any
        string in this list, when passed to `getExtension` on any
        platform or device, must return a valid extension object.
      </dd>

      <dt class="idl-code">void waitForEvents(WebCLEvent[] eventWaitList, optional WebCLCallback whenFinished, optional any userdata)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 Â§5.9</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clWaitForEvents.html">man page</a>)</span>
      </dt>
      <dd>
        Waits until the given events have completed. See WebCLEvent for more information.
      </dd>

    </dl>

    <h4><a id="WEBCL_Lifetime">Lifetime</a></h4>
The <a href="#WEBCL">WebCL</a> will live until the Window object or WorkerUtils object goes away.
<!-- ======================================================================================================= -->

    <h3><a id="WEBCLPLATFORM">WebCLPlatform</a></h3>

    <p>
    </p>

<pre class="idl">
interface <dfn>WebCLPlatform</dfn> {
  object getInfo(CLenum name);
  sequence&lt;WebCLDevice&gt; getDevices(CLenum deviceType);
  sequence&lt;DOMString&gt; getSupportedExtensions();
</pre>

    <dl class="methods">

      <dt class="idl-code">sequence&lt;WebCLDevice&gt; getDevices(optional CLenum deviceType)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=34">OpenCL 1.1 Â§4.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceIDs.html">man page</a>)</span>
      </dt>
      <dd>
        Retrieves the WebCLDevices that are available on this
        WebCLPlatform and match the given device type. The valid
        device types are listed in the table below.  Omitting the
        device type is equivalent to specifying `DEVICE_TYPE_DEFAULT`.
        <table class="foo">
          <tr><th>deviceType</th><th>description</th></tr>
          <tr><td>DEVICE_TYPE_CPU</td><td>A single-core or multi-core CPU, typically the host processor.</td></tr>
          <tr><td>DEVICE_TYPE_GPU</td><td>A graphics processing unit, typically also used by WebGL.</td></tr>
          <tr><td>DEVICE_TYPE_ACCELERATOR</td><td>A dedicated OpenCL accelerator.</td></tr>
          <tr><td>DEVICE_TYPE_DEFAULT</td><td>The default device on this platform.</td></tr>
          <tr><td>DEVICE_TYPE_ALL</td><td>All devices available on this platform.</td></tr>
        </table>
      </dd>

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=32">OpenCL 1.1 Â§4.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Retrieves information about this WebCLPlatform. The available
        query parameters are listed
        in <a href="#getPlatformInfoEnums">Chapter 4</a>.
      </dd>

      <dt class="idl-code">sequence&lt;DOMString&gt; getSupportedExtensions()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=269">OpenCL 1.1 Â§9</a>)</span>
      </dt>
      <dd>
        Returns an array of extension names that are supported by all
        WebCLDevices on this WebCLPlatform.  Any string in this list,
        when passed to `getExtension` on any device on this
        platform, must return a valid extension object.
      </dd>

    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLDEVICE">WebCLDevice</a></h3>

    <p>
    </p>

<pre class="idl">
interface <dfn>WebCLDevice</dfn> {
    any getInfo(CLenum name);
    object getExtension(DOMString extensionName);
    sequence&lt;DOMString&gt; getSupportedExtensions();
};
</pre>

    <dl class="methods">

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=36">OpenCL 1.1 Â§4.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceInfo.html">man page</a>)</span>
      </dt>
      <dd>
      <dd>
        Retrieves information about this WebCLDevice. The available
        query parameters are listed
        in <a href="#getDeviceInfoEnums">Chapter 4</a>.
      </dd>

      <dt class="idl-code">sequence&lt;DOMString&gt; getSupportedExtensions()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=269">OpenCL 1.1 Â§9</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Returns an array of extension names that are supported by this
        WebCLDevice. Any string in this list, when passed
        to `getExtension`, must return a valid extension
        object.
      </dd>

      <dt class="idl-code">object getExtension(DOMString extensionName)</dt>
      <dd>
        Enables the given WebCL extension on this WebCLDevice. Returns
        an object if the extension is supported by this device, or
        `null` if not.  The available extension names can be queried by
        `getSupportedExtensions`.  The returned object
        contains the constants and functions that are required by the
        extension, if any.  Even if the extension does not define any
        functions or constants, a valid object must still be returned.
        That object is used to indicate that the extension has been
        enabled. Multiple calls to `getExtension` with the
        same device and extension string must return the same object.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLCONTEXT">WebCLContext</a></h3>

    <p>
    </p>

    <pre class="idl">
interface <dfn>WebCLContext</dfn> {

    WebCLBuffer createBuffer(CLenum memFlags, CLuint sizeInBytes, optional ArrayBuffer hostPtr);

    WebCLCommandQueue createCommandQueue(optional WebCLDevice? device, optional CLenum properties);

    WebCLBuffer createFromGLBuffer(CLenum memFlags, WebGLBuffer buffer);

    WebCLImage createFromGLRenderBuffer(CLenum memFlags, WebGLRenderbuffer renderbuffer);

    WebCLImage createFromGLTexture(CLenum memFlags, GLenum textureTarget,
                                      GLint miplevel, WebGLTexture texture);

    WebCLImage createImage(CLenum memFlags,
                           WebCLImageDescriptor descriptor,
                           optional ArrayBuffer hostPtr);

    WebCLProgram createProgram(DOMString source);

    WebCLSampler createSampler(CLboolean normalizedCoords,
                               CLenum addressingMode,
                               CLenum filterMode);

    WebCLEvent createUserEvent();

    any getInfo(CLenum name);

    sequence&lt;WebCLImageDescriptor&gt; getSupportedImageFormats(CLenum memFlags,
                                                                  CLenum imageType);

    void release();
};
</pre>

<pre class="idl" id="WEBCLIMAGEDESCRIPTOR">
dictionary <dfn>WebCLImageDescriptor</dfn> {
  CLenum channelOrder = 0x10B5;            // 0x10B5 == WebCL.RGBA
  CLenum channelType = 0x10D2;             // 0x10D2 == WebCL.UNORM_INT8, 8-bit colors normalized to [0, 1]
  CLuint width = 0, height = 0;
  CLuint rowPitch = 0;
};
</pre>

    <dl class="methods">
      <dt class="idl-code">WebCLBuffer createBuffer(CLenum memFlags, CLuint sizeInBytes, optional ArrayBuffer hostPtr)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=56">OpenCL 1.1 Â§5.2.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateBuffer.html">man page</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLBuffer with a capacity of `sizeInBytes`,
        and optionally fills it with data from the given ArrayBuffer.
        <dl class="exceptions">
          <dt>Exceptions:</dt>
          <li>`INVALID_VALUE` -- if values specified in `memFlags` are not valid</li>
          <li>`INVALID_BUFFER_SIZE` -- if <code>sizeInBytes == 0 || sizeInBytes &gt; DEVICE_MAX_MEM_ALLOC_SIZE</code></li>
          <li>`INVALID_HOST_PTR` -- if <code>hostPtr.byteLength &lt; sizeInBytes</code></li>
        </dl>
      </dd>
      <dt class="idl-code">WebCLCommandQueue createCommandQueue(optional WebCLDevice? device = null, optional CLenum properties = 0)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=51">OpenCL 1.1 Â§5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateCommandQueue.html">man page</a>)</span>
      </dt>
      <dd>
        Creates a new command queue for the given device.  If `device`
        is `null`, the WebCL implementation will select any
        WebCLDevice that matches the given `properties` and is covered
        by this WebCLContext.  If `properties` is omitted, the command
        queue is created with out-of-order execution disabled and
        profiling disabled.
        <dl class="exceptions">
          <dt>Exceptions:</dt>
          <li>`INVALID_DEVICE` -- if `device` is invalid or not associated with this context</li>
          <li>`INVALID_VALUE` -- if values specified in `properties` are not valid</li>
          <li>`INVALID_QUEUE_PROPERTIES` -- if values specified in `properties` are valid but not supported by the device</li>
        </dl>
      </dd>
      <dt class="idl-code">WebCLBuffer createFromGLBuffer(CLenum memFlags, WebGLBuffer buffer)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=320">OpenCL 1.1 Â§9.8.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateFromGLBuffer.html">man page</a>)</span>
      </dt>
      <dd>
        This method is only valid if the WebCL context has been created with WebGL shared group.
      </dd>
      <dt class="idl-code">WebCLImage createFromGLRenderBuffer(CLenum memFlags, WebGLRenderbuffer renderbuffer)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=325">OpenCL 1.1 Â§9.8.4</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateFromGLRenderbuffer.html">man page</a>)</span>
      </dt>
      <dd>
        This method is only valid if the WebCL context has been created with WebGL shared group.
      </dd>
      <dt class="idl-code">WebCLImage createFromGLTexture(CLenum memFlags, GLenum textureTarget, GLint miplevel, WebGLTexture texture)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=321">OpenCL 1.1 Â§9.8.34</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateFromGLTexture2D.html">man page</a>)</span>
      </dt>
      <dd>
        This method is only valid if the WebCL context has been created with WebGL shared group.
      </dd>
      <dt class="idl-code">WebCLImage createImage(CLenum memFlags, WebCLImageDescriptor descriptor, optional ArrayBuffer hostPtr)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=76">OpenCL 1.1 Â§5.3.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateImage2D.html">man page</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLImage with the width and height specified
        in `descriptor`, and optionally fills it with data from the
        given ArrayBuffer.  
        <dl class="exceptions">
          <dt>Exceptions:</dt>
          <li>`INVALID_VALUE` -- if values specified in `memFlags` are not valid</li>
          <li>`INVALID_IMAGE_SIZE` -- if <code>descriptor.width == 0 || descriptor.width &gt; DEVICE_IMAGE2D_MAX_WIDTH</code>
          <li>`INVALID_IMAGE_SIZE` -- if <code>descriptor.height == 0 || descriptor.height &gt; DEVICE_IMAGE2D_MAX_HEIGHT</code>
          <li>`INVALID_HOST_PTR` -- if <code>hostPtr.byteLength &lt; descriptor.rowPitch * descriptor.height</code></li>
          <li>`INVALID_IMAGE_FORMAT_DESCRIPTOR` -- if `descriptor.channelOrder` or `descriptor.channelType` is not valid</li>
          <li>`IMAGE_FORMAT_NOT_SUPPORTED` -- if the given combination of `channelOrder` and `channelType` is not supported</li>
        </dl>
      </dd>
      <dt class="idl-code">WebCLProgram createProgram(DOMString source)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=110">OpenCL 1.1 Â§5.6.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateProgramWithSource.html">man page</a>)</span>
      </dt>
      <dd>
        Creates a WebCLProgram from a UTF-8 string.
        <dl class="exceptions">
          <dt>Exceptions:</dt>
          <li>`INVALID_VALUE` -- if `source` is `null` or empty</li>
        </dl>
      </dd>
      <dt class="idl-code">WebCLSampler createSampler(CLboolean normalizedCoords, CLenum addressingMode, CLenum filterMode)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=106">OpenCL 1.1 Â§5.5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateSampler.html">man page</a>)</span>
      </dt>
      <dd>
        <dl class="exceptions">
          <dt>Exceptions:</dt>
          <li>`INVALID_VALUE` -- if `addressingMode`, `filterMode`, or `normalizedCoords` or a combination of these argument values are not valid</li>
        </dl>
      </dd>
      <dt class="idl-code">WebCLEvent createUserEvent()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=142">OpenCL 1.1 Â§5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateUserEvent.html">man page</a>)</span>
      </dt>
      <dd>
      </dd>
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=49">OpenCL 1.1 Â§4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetContextInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Returns the value for the passed name. The type returned is the natural type for the
        requested name, as given in the following table:
        <table class="foo">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>CONTEXT_NUM_DEVICES</td><td>CLuint</td></tr>
          <tr><td>CONTEXT_DEVICES</td><td>WebCLDevice[]</td></tr>
          <tr><td>CONTEXT_PROPERTIES</td><td>WebCLContextProperties</td></tr>
        </table><br>
      </dd>
      <dt class="idl-code">sequence&lt;WebCLImageDescriptor&gt; getSupportedImageFormats(CLenum memFlags, CLenum imageType)</dt>
      <dd>
      </dd>
      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=48">OpenCL 1.1 Â§4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseContext.html">man page</a>)</span>
      </dt>
      <dd>
        Decrements the native context reference count. After the
        context reference count becomes zero and all objects
        attached to context (such as memory objects,
        command-queues) are released, the context is deleted.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLCOMMANDQUEUE">WebCLCommandQueue</a></h3>

<pre class="idl">
interface <dfn>WebCLCommandQueue</dfn> {

  ////////////////////////////////////////////////////////////////////////////
  //
  // Copying: Buffer <-> Buffer, Image <-> Image, Buffer <-> Image
  //

void enqueueCopyBuffer(
                    WebCLBuffer             srcBuffer,
                    WebCLBuffer             dstBuffer,
                    CLuint                  srcOffset,
                    CLuint                  dstOffset,
                    CLuint                  sizeInBytes,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueCopyBufferRect(
                    WebCLBuffer             srcBuffer,
                    WebCLBuffer             dstBuffer,
                    CLuint[3]               srcOrigin,
                    CLuint[3]               dstOrigin,
                    CLuint[3]               region,
                    CLuint                  srcRowPitch,
                    CLuint                  srcSlicePitch,
                    CLuint                  dstRowPitch,
                    CLuint                  dstSlicePitch,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueCopyImage(
                    WebCLImage              srcImage,
                    WebCLImage              dstImage,
                    CLuint[3]               srcOrigin,
                    CLuint[3]               dstOrigin,
                    CLuint[3]               region,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueCopyImageToBuffer(
                    WebCLImage              srcImage,
                    WebCLBuffer             dstBuffer,
                    CLuint[3]               srcOrigin,
                    CLuint[3]               region,
                    CLuint                  dstOffset,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueCopyBufferToImage(
                    WebCLBuffer             srcBuffer,
                    WebCLImage              dstImage,
                    CLuint                  srcOffset,
                    CLuint[3]               dstOrigin,
                    CLuint[3]               region,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Reading: Buffer -> Host, Image -> Host
  //

void enqueueReadBuffer(
                    WebCLBuffer             buffer,
                    CLboolean               blockingRead,
                    CLuint                  offset,
                    CLuint                  sizeInBytes,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueReadBufferRect(
                    WebCLBuffer             buffer,
                    CLboolean               blockingRead,
                    CLuint[3]               bufferOrigin,
                    CLuint[3]               hostOrigin,
                    CLuint[3]               region,
                    CLuint                  bufferRowPitch,
                    CLuint                  bufferSlicePitch,
                    CLuint                  hostRowPitch,
                    CLuint                  hostSlicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueReadImage(
                    WebCLImage              image,
                    CLboolean               blockingRead,
                    CLuint[3]               origin,
                    CLuint[3]               region,
                    CLuint                  rowPitch,
                    CLuint                  slicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Writing: Host -> Buffer, Host -> Image
  //

void enqueueWriteBuffer(
                    WebCLBuffer             buffer,
                    CLboolean               blockingWrite,
                    CLuint                  offset,
                    CLuint                  sizeInBytes,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueWriteBufferRect(
                    WebCLBuffer             buffer,
                    CLboolean               blockingWrite,
                    CLuint[3]               bufferOrigin,
                    CLuint[3]               hostOrigin,
                    CLuint[3]               region,
                    CLuint                  bufferRowPitch,
                    CLuint                  bufferSlicePitch,
                    CLuint                  hostRowPitch,
                    CLuint                  hostSlicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

void enqueueWriteImage(
                    WebCLImage              image,
                    CLboolean               blockingWrite,
                    CLuint[3]               origin,
                    CLuint[3]               region,
                    CLuint                  inputRowPitch,
                    CLuint                  inputSlicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Acquiring and releasing WebGL objects
  //

  void enqueueAcquireGLObjects(WebCLMemoryObject[] memObjects,
                               optional WebCLEvent[]? eventWaitList,
                               optional WebCLEvent? event);

  void enqueueReleaseGLObjects(WebCLMemoryObject[] memObjects,
                               optional WebCLEvent[]? eventWaitList,
                               optional WebCLEvent? event);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Executing kernels
  //

  void enqueueNDRangeKernel(WebCLKernel kernel,
                            CLuint[]? offsets, CLuint[]? globals, CLuint[]? locals,
                            optional WebCLEvent[]? eventWaitList,
                            optional WebCLEvent? event);

  void enqueueTask(WebCLKernel kernel,
                   optional WebCLEvent[]? eventWaitList,
                   optional WebCLEvent? event);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Synchronization
  //

  void enqueueMarker(optional WebCLEvent[]? eventWaitList, optional WebCLEvent? event);

  void enqueueBarrier(optional WebCLEvent[]? eventWaitList, optional WebCLEvent? event);

  void finish();

  void flush();

  ////////////////////////////////////////////////////////////////////////////
  //
  // Querying command queue information
  //

  any getInfo(CLenum name);

  void release();
};
</pre>

    <dl class="methods">

        <dt class="idl-code">void enqueueCopyBuffer(
                    WebCLBuffer             srcBuffer,
                    WebCLBuffer             dstBuffer,
                    CLuint                  srcOffset,
                    CLuint                  dstOffset,
                    CLuint                  sizeInBytes,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyBufferRect.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueCopyImage(
                    WebCLImage              srcImage,
                    WebCLImage              dstImage,
                    CLuint[3]               srcOrigin,
                    CLuint[3]               dstOrigin,
                    CLuint[3]               region,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyImage.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueCopyBufferToImage(
                    WebCLBuffer             srcBuffer,
                    WebCLImage              dstImage,
                    CLuint                  srcOffset,
                    CLuint[3]               dstOrigin,
                    CLuint[3]               region,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.3.4">OpenCL 1.1 Â§5.3.4</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyBufferToImage.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueCopyImageToBuffer(
                    WebCLImage              srcImage,
                    WebCLBuffer             dstBuffer,
                    CLuint[3]               srcOrigin,
                    CLuint[3]               region,
                    CLuint                  dstOffset,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.3.4">OpenCL 1.1 Â§5.3.4</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyImageToBuffer.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueReadBuffer(
                    WebCLBuffer             buffer,
                    CLboolean               blockingRead,
                    CLuint                  offset,
                    CLuint                  sizeInBytes,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReadBuffer.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueReadImage(
                    WebCLImage              image,
                    CLboolean               blockingRead,
                    CLuint[3]               origin,
                    CLuint[3]               region,
                    CLuint                  rowPitch,
                    CLuint                  slicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReadImage.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueReadBufferRect(
                    WebCLBuffer             buffer,
                    CLboolean               blockingRead,
                    CLuint[3]               bufferOrigin,
                    CLuint[3]               hostOrigin,
                    CLuint[3]               region,
                    CLuint                  bufferRowPitch,
                    CLuint                  bufferSlicePitch,
                    CLuint                  hostRowPitch,
                    CLuint                  hostSlicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReadBufferRect.html">man page</a>)</span>
        </dt>
        <dd>
        </dd>

        <dt class="idl-code">void enqueueWriteBuffer(
                    WebCLBuffer             buffer,
                    CLboolean               blockingWrite,
                    CLuint                  offset,
                    CLuint                  sizeInBytes,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWriteBuffer.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueWriteImage(
                    WebCLImage              image,
                    CLboolean               blockingWrite,
                    CLuint[3]               origin,
                    CLuint[3]               region,
                    CLuint                  inputRowPitch,
                    CLuint                  inputSlicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWriteImage.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueWriteBufferRect(
                    WebCLBuffer             buffer,
                    CLboolean               blockingWrite,
                    CLuint[3]               bufferOrigin,
                    CLuint[3]               hostOrigin,
                    CLuint[3]               region,
                    CLuint                  bufferRowPitch,
                    CLuint                  bufferSlicePitch,
                    CLuint                  hostRowPitch,
                    CLuint                  hostSlicePitch,
                    ArrayBuffer             ptr,
                    optional WebCLEvent[]?  eventWaitList,
                    optional WebCLEvent?    event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 Â§5.2.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWriteBufferRect.html">man page</a>)</span>
        </dt>
        <dd>
        </dd>

        <dt class="idl-code">void enqueueAcquireGLObjects(WebCLMemoryObject[] memObjects,
          optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null);
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-9.8.6">OpenCL 1.1 Â§9.8.6</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueAcquireGLObjects.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueReleaseGLObjects(WebCLMemoryObject[] memObjects,
          optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null);
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-9.8.6">OpenCL 1.1 Â§9.8.6</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReleaseGLObjects.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueNDRangeKernel(WebCLKernel kernel, CLuint[3] offsets, CLuint[3] globals,
          CLuint[3] locals, optional WebCLEvent[]? eventWaitList = null,
          optional WebCLEvent? event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.8">OpenCL 1.1 Â§5.8</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueNDRangeKernel.html">man page</a>)</span>
        </dt>
            <dd>
            Offsets, globals, locals contain 1, 2, or 3 NDRange values. The number of dimensions is determined by the number of elements in globals.
            </dd>

        <dt class="idl-code">void enqueueTask(WebCLKernel kernel, optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.8">OpenCL 1.1 Â§5.8</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueTask.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueMarker(optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.10">OpenCL 1.1 Â§5.10</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueMarker.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void enqueueBarrier(optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.10">OpenCL 1.1 Â§5.10</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueBarrier.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void finish()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.13">OpenCL 1.1 Â§5.13</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clFinish.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">void flush()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.13">OpenCL 1.1 Â§5.13</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clFlush.html">man page</a>)</span>
        </dt>
            <dd>
            </dd>

        <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.1">OpenCL 1.1 Â§5.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetCommandQueueInfo.html">man page</a>)</span>
        </dt>
            <dd>
            Return the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>return type</th></tr>
                <tr><td>QUEUE_CONTEXT</td><td>WebCLContext</td></tr>
                <tr><td>QUEUE_DEVICE</td><td>WebCLDevice</td></tr>
                <tr><td>QUEUE_PROPERTIES</td><td>CLenum</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=53">OpenCL 1.1 Â§5.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseCommandQueue.html">man page</a>)</span>
        </dt>
            <dd>
            Decrement the native command queue reference count. After the command queue reference count becomes zero and all commands queued to this command queued have finished, the command queue is deleted.
            </dd>
    </dl>

<pre class="example">
// This example shows how to wait for two kernels to complete before a
// third kernel executes

var eventWaitList = [ new WebCLEvent(), new WebCLEvent() ];
queue.enqueueNDRangeKernel(kernel1, null, globals, null, null, eventWaitList[0]);
queue.enqueueNDRangeKernel(kernel2, null, globals, null, null, eventWaitList[1]);
queue.enqueueNDRangeKernel(kernel3, null, globals, null, eventWaitList);
</pre>

<pre class="example">
// This example reads the entire contents of a WebCL buffer object
// into a newly created ArrayBuffer in host memory.

function readBufferToHost(srcBuffer) {

 // Query the number of bytes in the source buffer, and create a new
 // ArrayBuffer of that size.

 var numBytes = srcBuffer.getInfo(WebCL.MEM_SIZE);
 var dstArray = new ArrayBuffer(numBytes);

 // For reading the contents of a buffer object from CL to the host,
 // we must specify the number of bytes to read. Optionally, we could
 // also specify the starting offset (origin[0]).

 queue.enqueueReadBuffer(srcBuffer, true, 0, numBytes, dstArray);

 return dstArray;
};
</pre>

<pre class="example">
// This example fills a WebCL image with pixels from a WebCL buffer.

function copyBufferToImage(srcBuffer, dstImage) {

  // Extract the dimensions of the image.

  var imgWidth = dstImage.getInfo(WebCL.IMAGE_WIDTH);
  var imgHeight = dstImage.getInfo(WebCL.IMAGE_HEIGHT);

  // The source buffer region can be specified with just the buffer,
  // because only the 'origin' field is needed, and we are fine with
  // its default value (zero). For the destination region, we use the
  // default origin (0, 0), but must specify the width and height.

  queue.enqueueCopyBufferToImage(srcBuffer, dstImage, 0, [0,0], [imgWidth, imgHeight]);
};
</pre>

<pre class="example">
// This example copies a rectangular region of memory from a
// buffer object to another.  The buffer objects are assumed
// to be the same size. The origin, width, height, and pitch
// (a.k.a. row stride) are given in bytes (not pixels, because
// these are buffers rather than images).

function copyBufferRect(srcBuffer, dstBuffer, srcX, srcY, dstX, dstY, w, h, pitch) {

  // The source and destination regions must have the same width
  // and height (as required by the underlying OpenCL function).
  // The row pitch could be different for source and destination,
  // but is assumed to be the same in this example.

  queue.enqueueCopyBuffer(srcBuffer, true, [srcX, srcY], [dstX, dstY], [w, h],
                          pitch, 0, pitch, 0, dstBuffer);
};
</pre>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLMEMORYOBJECT">WebCLMemoryObject</a></h3>

<pre class="idl">interface <dfn>WebCLMemoryObject</dfn> : Transferable {
  any getInfo(CLenum name);
  WebCLGLObjectInfo getGLObjectInfo();

  void release();
};
</pre>

    <dl class="methods">
        <dt class="idl-code">any getInfo(CLenum name)</dt>
            <dd>
            Returns the value for the passed name. The type returned is the natural type for the
            requested name, as given in the following table:
            <table class="foo">
                <tr><th>name</th><th>return type</th><th>return value</th></tr>
                <tr><td>`MEM_TYPE`</td><td>`CLenum`</td><td>`MEM_OBJECT_BUFFER` or `MEM_OBJECT_IMAGE2D`</td></tr>
                <tr><td>`MEM_FLAGS`</td><td>`CLenum`</td><td>The `memFlags` as specified at construction time</td></tr>
                <tr><td>`MEM_SIZE`</td><td>`CLuint`</td><td>The size of this memory object in bytes</td></tr>
                <tr><td>`MEM_CONTEXT`</td><td>`WebCLContext`</td><td>the WebCL context of this memory object</td></tr>
                <tr><td>`MEM_ASSOCIATED_MEMOBJECT`</td><td>`WebCLBuffer`</td><td>The buffer
                    object that this buffer was created from, or `null`
                    if this buffer was not created using `createSubBuffer`</td></tr>
                <tr><td>`MEM_OFFSET`</td><td>`CLuint`</td><td>The offset given to `createSubBuffer`,
                    or zero if this buffer was not created using `createSubBuffer`</td></tr>
            </table><br>
            </dd>
        <dt class="idl-code">WebCLGLObjectInfo getGLObjectInfo()</dt>
            <dd>
            Warning: this method is valid only if WebCL context was created with a WebGL shared group.<br>

            WebCLGLObjectInfo is defined as the following dictionary:
<pre class="idl" id="WEBCLGLOBJECTINFO">
dictionary <dfn>WebCLGLObjectInfo</dfn> {
  CLenum type;   // type of GL object attached to this memory object
  any glObject;  // The GL object used to create this memory object
};
</pre>
            </dd>
        <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=99">OpenCL 1.1 Â§5.4.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseMemObject.html">man page</a>)</span>
        </dt>
            <dd>
            Decrement the native memory object reference count. After the memory object reference count becomes zero and commands queued for execution on a command-queue(s) that use this memory object have finished, the memory object is deleted.
            </dd>
   </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLBUFFER">WebCLBuffer</a></h3>

     <p>
     </p>

<pre class="idl">interface <dfn>WebCLBuffer</dfn> : WebCLMemoryObject {
  WebCLBuffer createSubBuffer(CLenum flags, CLuint origin, CLuint size);
};
</pre>

    <dl class="methods">
      <dt class="idl-code">WebCLBuffer createSubBuffer(CLenum flags, CLuint origin, CLuint size)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.1">OpenCL 1.1 Â§5.2.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateSubBuffer.html">man page</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLBuffer that represents a sub-region of this
        WebCLBuffer. The two buffers reference the same area of global
        memory, so changes made into one are immediately reflected in
        the other.
      </dd>
    </dl>

 <!-- ======================================================================================================= -->

    <h3><a id="WEBCLIMAGE">WebCLImage</a></h3>

    <p>
    </p>

<pre class="idl">interface <dfn>WebCLImage</dfn> : WebCLMemoryObject {
  WebCLImageDescriptor getInfo();
  GLint getGLtextureInfo(CLenum paramName);
};
</pre>

   <dl class="methods">
     <dt class="idl-code">WebCLImageDescriptor getInfo()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=97">OpenCL 1.1 Â§5.3.6</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetImageInfo.html">man page</a>)</span>
      </dt>
     <dd>
       Returns a new WebCLImageDescriptor containing information about
       the pixel format and dimensions of this WebCLImage.
     </dd>
     <dt class="idl-code">GLint getGLTextureInfo(CLenum paramName)</dt>
       <dd>
         Warning: this method is only available if WebCLContext was created with a WebGL shared group.<br>
         Returns texture values used in WebCLContext.createFromGLTexture() to create this memory object from a WebGL texture.
       </dd>
   </dl>


<!-- ======================================================================================================= -->

    <h3><a id="WEBCLSAMPLER">WebCLSampler</a></h3>

    <p>
    </p>
    <pre class="idl">
interface <dfn>WebCLSampler</dfn> {
    any getInfo(CLenum name);
    void release();

};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=108">OpenCL 1.1 Â§5.5.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetSamplerInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Return the value for the passed name. The type returned is the natural type for the
        requested name, as given in the following table:
        <table class="foo">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>SAMPLER_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>SAMPLER_NORMALIZED_COORDS</td><td>CLboolean</td></tr>
          <tr><td>SAMPLER_ADDRESSING_MODE</td><td>CLenum</td></tr>
          <tr><td>SAMPLER_FILTER_MODE</td><td>CLenum</td></tr>
        </table><br>
      </dd>
      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=107">OpenCL 1.1 Â§5.5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseSampler.html">man page</a>)</span>
      </dt>
      <dd>
        Decrement the native sampler reference count. The sampler object is deleted after the reference count becomes zero and commands queued for execution on a command-queue(s) that use sampler have finished.
      </dd>
    </dl>

<!-- ======================================================================================================= -->
    <h3><a id="WEBCLPROGRAM">WebCLProgram</a></h3>

    <p>
    </p>
    <pre class="idl">
interface <dfn>WebCLProgram</dfn> {
    any getInfo(CLenum name);

    any getBuildInfo(WebCLDevice device, CLenum name);

    void build(WebCLDevice[] devices,
               optional DOMString? options,
               optional WebCLCallback whenFinished,
               optional any userdata);

    WebCLKernel createKernel(DOMString kernelName);

    sequence&lt;WebCLKernel&gt; createKernelsInProgram();

    void release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=119">OpenCL 1.1 Â§5.6.5</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetProgramInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Return the value for the passed name. The type returned is the natural type for the
        requested name, as given in the following table:
        <table class="foo">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>PROGRAM_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>PROGRAM_NUM_DEVICES</td><td>CLuint</td></tr>
          <tr><td>PROGRAM_DEVICES</td><td>WebCLDevice[]</td></tr>
          <tr><td>PROGRAM_SOURCE</td><td>DOMString</td></tr>
        </table><br>
      </dd>
      <dt class="idl-code">any getBuildInfo(WebCLDevice device, CLenum name)</dt>
      <dd>
        return Integer or DOMString depending on name queried.
      </dd>
      <dt class="idl-code">void build(WebCLDevice[] devices,
        optional DOMString? options,
        optional WebCLCallback whenFinished,
        optional any userdata)</dt>
      <dd>
        Compile a program with optional compiler options.  An
        asynchronous callback method may be provided with
        optional userdata.
      </dd>
      <dt class="idl-code">WebCLKernel createKernel(DOMString name)</dt>
      <dd>
      </dd>
      <dt class="idl-code">sequence&lt;WebCLKernel&gt; createKernelsInProgram()</dt>
      <dd>
      </dd>
      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=113">OpenCL 1.1 Â§5.6.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseProgram.html">man page</a>)</span>
      </dt>
      <dd>
        Decrement the native program reference count. The program object is deleted after all kernel objects associated with program have been deleted and the program reference count becomes zero.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLKERNEL">WebCLKernel</a></h3>

    <p>
      The following methods are available for setting kernel arguments
      and querying kernel-specific information.
    </p>

<pre class="idl">
interface <dfn>WebCLKernel</dfn> {
    any getInfo(CLenum name);
    any getWorkGroupInfo(WebCLDevice device, CLenum name);
    void setArg(CLuint index, any value, optional CLtype type);
    void release();
};
</pre>

    <p id="WEBCLKERNELARGUMENTTYPES">
      The following enumerated values are available for specifying the
      `type` of kernel arguments in `setArg`.  Vector types are
      specified by bitwise-`OR`'ing one of the scalar enums with exactly
      one of the vector enums (`VEC2`, `VEC3`, `VEC4`, `VEC8`, or
      `VEC16`).  The special type `LOCAL_MEMORY_SIZE` is used to
      allocate memory for local variables.
    </p>

<pre class="idl">
interface <dfn>WebCLKernelArgumentTypes</dfn> {

  // Scalar types; may be bitwise-OR'ed with a vector type

  CLtype CHAR   = 0;
  CLtype UCHAR  = 1;
  CLtype SHORT  = 2;
  CLtype USHORT = 3;
  CLtype INT    = 4;
  CLtype UINT   = 5;
  CLtype LONG   = 6;
  CLtype ULONG  = 7;
  CLtype FLOAT  = 8;
  CLtype HALF   = 9;    // not supported in all implementations
  CLtype DOUBLE = 10;   // not supported in all implementations

  // Vector types; must be bitwise-OR'ed with a scalar type

  CLtype VEC2  = 0x0100;
  CLtype VEC3  = 0x0200;
  CLtype VEC4  = 0x0400;
  CLtype VEC8  = 0x0800;
  CLtype VEC16 = 0x1000;

  // Special types; must not be bitwise-OR'ed with any other type

  CLtype LOCAL_MEMORY_SIZE = 255;
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=129">OpenCL 1.1 Â§5.7.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetKernelInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Return the value for the passed name. The type returned is the natural type for the
        requested name, as given in the following table:
        <table class="foo">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>KERNEL_FUNCTION_NAME</td><td>DOMString</td></tr>
          <tr><td>KERNEL_NUM_ARGS</td><td>CLuint</td></tr>
          <tr><td>KERNEL_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>KERNEL_PROGRAM</td><td>WebCLProgram</td></tr>
        </table><br>
      </dd>
      <dt class="idl-code">any getWorkGroupInfo(CLenum name)</dt>
      <dd>
        return an Integer or Integer[1..3] depending on the name queried.
      </dd>

      <dt class="idl-code">void setArg(CLuint index, any value, optional CLtype type)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.7.2">OpenCL 1.1 Â§5.7.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetKernelArg.html">man page</a>)</span>
      </dt>
      <dd>
        <p>
          Sets the given `value` to the kernel argument at the given
          `index`.  Legal values for `index` range from zero to `N-1`,
          where `N` is the total number of arguments declared by the
          kernel.  The available values for the optional `type`
          parameter are documented in
          <a href="#WEBCLKERNELARGUMENTTYPES">WebCLKernelArgumentTypes</a>.
        </p>
        <p>
          The `type` parameter is ignored if `value` is an instance of
          WebCLBuffer, WebCLImage, or WebCLSampler.  If `value` is a
          number, its `type` is taken to be `FLOAT` by default.  If
          `value` is an array, the same applies for its individual
          elements.  If `value` is of any other type, an exception
          will be thrown.
        </p>
        <p>
          Numbers are converted to the given or implied scalar type by
          rounding and clamping to the available range and precision.
          For example, if the `UCHAR` type is given, the values 254.9
          and 1000 will both be mapped to 255. <b>(Q: Should we use
          standard C-style type casting instead, i.e., modulo
          arithmetic instead of clamping?)</b>
        </p>
        <p>
          If `value` is an array, and `type` does not specify a vector
          width, the array length is rounded down to the nearest
          available vector width (1, 2, 3, 4, 8, or 16).  If the given
          or implied vector width does not match the length of the
          `value` array, any missing elements are taken to be zero,
          and any extra elements in the array are ignored.  If any of
          the required array elements are not numbers, an exception
          will be thrown.
        </p>
      </dd>

        <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=126">OpenCL 1.1 Â§5.7.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseKernel.html">man page</a>)</span>
        </dt>
            <dd>
            Decrement the native kernel reference count. The kernel object is deleted once the number of instances that are retained to this kernel become zero and this kernel object is no longer needed by any enqueued commands that use this kernel.
            </dd>

    </dl>

<pre class="example">
var types = WebCLKernelArgumentTypes;
myKernel.setArg(0, 3.14159, types.FLOAT);                     // cast 3.14159 to FLOAT, then pass to kernel as arg #0
myKernel.setArg(1, [1.23, 2.34], types.UINT | types.VEC2);    // cast the numbers to UINT, then pass to kernel as arg #1
myKernel.setArg(2, 512, types.LOCAL_MEMORY_SIZE);             // reserve 512 bytes of local memory for arg #2
</pre>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLEVENT">WebCLEvent</a></h3>

    <p>
      OpenCL's Event and UserEvent are merged into this WebCLEvent
      class.
    </p>

<pre class="idl">
[Constructor]
interface <dfn>WebCLEvent</dfn> {
    readonly attribute CLenum status;
    readonly attribute WebCLMemoryObject buffer;

    any   getInfo(CLenum name);
    any   getProfilingInfo(CLenum name);
    void  setUserEventStatus(CLenum executionStatus);
    void  setCallback(CLenum executionStatus, WebCLCallback notify, optional any userdata);
    void  release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 Â§5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetEventInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Return the value for the passed name. The type returned is the natural type for the
        requested name, as given in the following table:
        <table class="foo">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>EVENT_COMMAND_QUEUE</td><td>WebCLCommandQueue</td></tr>
          <tr><td>EVENT_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>EVENT_COMMAND_TYPE</td><td>CLenum</td></tr>
          <tr><td>EVENT_COMMAND_EXECUTION_STATUS</td><td>CLenum</td></tr>
        </table><br>
      </dd>

      <dt class="idl-code">any getProfilingInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.12">OpenCL 1.1 Â§5.12</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetEventProfilingInfo.html">man page</a>)</span>
      </dt>
      <dd>
        Return the value for the passed name. The type returned is the natural type for the
        requested name, as given in the following table:
        <table class="foo">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>PROFILING_COMMAND_QUEUED</td><td>CLuint</td></tr>
          <tr><td>PROFILING_COMMAND_SUBMIT</td><td>CLuint</td></tr>
          <tr><td>PROFILING_COMMAND_START</td><td>CLuint</td></tr>
          <tr><td>PROFILING_COMMAND_END</td><td>CLuint</td></tr>
        </table><br>
      </dd>

      <dt class="idl-code">void setUserEventStatus(CLenum executionStatus)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 Â§5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetUserEventStatus.html">man page</a>)</span>
      </dt>
      <dd>
      </dd>

      <dt class="idl-code">void setCallback(CLenum executionStatus, WebCLCallback notify, optional any userdata)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 Â§5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetEventCallback.html">man page</a>)</span>
      </dt>
      <dd>
        Sets a WebCLCallback function `notify` to be called when
        this WebCLEvent reaches the given `executionStatus`
        (`COMPLETE`, `RUNNING`, `SUBMITTED`, or `QUEUED`).
      </dd>
      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=149">OpenCL 1.1 Â§5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseEvent.html">man page</a>)</span>
      </dt>
      <dd>
        Decrements the native event reference count. This event object
        is deleted once the reference count becomes zero, the specific
        command identified by this event has completed (or terminated)
        and there are no commands in the command-queues of a context
        that require a wait for this event to complete.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h2>Security and Robustness</h2>

    <p>
      To promote robustness of the WebCL standard, the working group
      is actively working on identifying and remediating potential
      vulnerabilities.  Depending upon the nature of the issue, the
      remediation may need to be addressed by the OpenCL Working Group
      or the WebCL Working Group, or both.  The working group has
      identified the following security requirements for WebCL.
    </p>

    <h3>Undefined Behavior</h3>
      Behavior left undefined in OpenCL will be defined by the WebCL specification
      where possible, to ensure the authoring of strong conformance tests, and to
      prevent the potential introduction of security vulnerabilities resulting
      from undefined behavior.
    </h3>

    <h3>Cross-Origin Information Leakage</h3>

    <p>
     WebCL will restrict the use of media, such as image and video, originating from
     a different web site than the hosting web page.  WebCL will leverage provisions
     such as Cross-Origin Resource Sharing (CORS) to help enforce the restriction on
     the use of media by a web page different than the originating web site.
    </p>


    <h3>Out-of-Range Memory Accesses</h3>

    <p>
     To ensure that all accessed indices are valid, protections will be provided
     against out of bounds memory writes.  Out of bounds memory reads should not
     return any uninitialized value.
    </p>


    <h3> Memory Initialization</h3>

    <p>
     To prevent information leakage from un-initialized memory, all WebCL
     allocated memory objects (buffers and images), inclusive of private and
     local variables in kernel code, must be initialized at allocation time
     (before the application will be allowed to use them).  To minimize the
     performance burden on applications for initializing allocated memory to
     zeroes, WebCL implementations will ensure that memory is initialized
     to a pre-defined value at allocation time.
    </p>


    <h3>Cross-Context Information Leakage</h3>

    <p>
     WebCL implementations must ensure that no information can leak
     from one WebCL/OpenCL context to another. It must not be
     possible for WebCL kernels or host code to access arbitrary
     system memory, or memory from another OpenCL/WebCL context.
    </p>


    <h3>Denial of Service (DoS)</h3>

    <p>
     Long running and/or computationally intensive kernels may cause the
     system to become unresponsive, and can lead to denial of
     service. It is not acceptable for content downloaded over the
     internet to lock up the browser.

     To prevent bugs/issues in unknown and untrusted code from monopolizing
     an OpenCL device and making it unresponsive, WebCL implementations need to
     be able to:
    </p>

    <ul>
    <li> Detect offending kernels.  A kernel is considered "offending"
         if it runs for an excessively long time, or disproportionately
         consumes system resources.
    <li> Terminate contexts associated with long-running malicious or
         erroneous kernels, before they render the OpenCL device
         unresponsive, and result in potential device reset.
    </ul>

<!-- ======================================================================================================= -->

    <h2>Interoperability with HTML Canvas, Image and Video Elements</h2>

<div class="strawman">

    <p>
      This section proposes mechanisms for transferring pixel data
      between WebCL memory objects and HTML media elements.
      Server-side or Web Worker based implementations of WebCL will
      not be required to support these features.
    </p>

    <h3>Creating WebCL memory objects</h3>

    <p>
      A newly created WebCLBuffer or WebCLImage can be initialized
      from an ImageData, Canvas, or Image element.  This does not
      create a binding of any kind between the WebCL memory object and
      the data source.  The source pixel format is treated as 32-bit
      RGBA (8 bits per component) with non-premultiplied alpha,
      regardless of the source.  The newly created WebCLImage will
      have `channelOrder` equal to `RGBA`, `channelType` equal to
      `UNORM_INT8`, and width and height equal to the source width
      and height.
    </p>

<pre class="idl">
partial interface WebCLContext {
  WebCLBuffer createBuffer(CLenum memFlags, ImageData srcPixels);
  WebCLBuffer createBuffer(CLenum memFlags, HTMLCanvasElement srcCanvas);
  WebCLBuffer createImage(CLenum memFlags, HTMLImageElement srcImage);
  WebCLImage createImage(CLenum memFlags, ImageData srcPixels);
  WebCLImage createImage(CLenum memFlags, HTMLCanvasElement srcCanvas);
  WebCLImage createImage(CLenum memFlags, HTMLImageElement srcImage);
};
</pre>

    <p>
      The size in bytes of a new WebCLBuffer is computed from the
      source as follows:
    </p>

    <ul>
      <li>For ImageData sources, the buffer size is `srcPixels.data.length`.
      <li>For HMTLCanvasElement sources, the buffer size is <code>srcCanvas.getContext("2d").getImageData().data.length</code>.
      <li>For HTMLImageElement sources, the buffer size is <code>srcImage.width * srcImage.height * 4</code>.
    </ul>

    <h3>Binding with HTMLVideoElement</h3>

    <p>
      A newly created WebCLImage can be permanently bound to an HTML
      video element.  `enqueueWriteImage` from a video element is only
      allowed when the video element is bound to the target
      WebCLImage. Note that `memFlags` must be equal to
      `MEM_READ_ONLY`.
    </p>

<pre class="idl">
partial interface WebCLContext {
  WebCLImage createImage(CLenum memFlags, HTMLVideoElement srcVideo);
};
</pre>

    <p>
      To allow the application to query information from a WebCLImage
      that is bound to an HTMLVideoElement, the WebCLImageDescriptor
      dictionary is extended as follows:
    </p>

<pre class="idl">
dictionary <dfn>WebCLVideoDescriptor</dfn> : WebCLImageDescriptor {
  CLint framesPerSecond = -1;         // video frame rate, -1 if unknown
  CLint currentEnqueuedFrame = -1;    // -1, 0 to totalFrames-1
  CLint totalFrames = -1;             // -1 if unknown or "live" / streaming
};
</pre>

    <p>
      The `currentEnqueuedFrame` field is set by each invocation of
      `enqueueWriteImage`. It indicates which frame is scheduled to be
      written into the WebCLImage. If the value is -1, then no frame
      is scheduled.
    </p>

    <h3>Reading and writing HTML elements</h3>
<div class="strawman">
<p>[bug 8812] if WebCLRegion is removed, all these methods must be rewritten to follow OpenCL
signature, as proposed in WebCLCommandQueue section.</p>
</div>

<pre class="idl">
partial interface WebCLCommandQueue {

  //////////////////////////////////////////////////////////////////////
  //
  // Writing to WebCLBuffer
  //

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          ImageData srcPixels,
                          CLboolean blockingWrite,
                          optional WebCLEvent[]? eventWaitList,
                          optional WebCLEvent? event);

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          HTMLCanvasElement srcCanvas,
                          CLboolean blockingWrite,
                          optional WebCLEvent[]? eventWaitList,
                          optional WebCLEvent? event);

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          HTMLImageElement srcImage,
                          CLboolean blockingWrite,
                          optional WebCLEvent[]? eventWaitList,
                          optional WebCLEvent? event);

  void enqueueWriteBufferRect(WebCLRegion dstBuffer,
                              ImageData srcPixels,
                              WebCLRegion srcRegion,
                              CLboolean blockingWrite,
                              optional WebCLEvent[]? eventWaitList,
                              optional WebCLEvent? event);

  void enqueueWriteBufferRect(WebCLRegion dstBuffer,
                              HTMLCanvasElement srcCanvas,
                              WebCLRegion srcRegion,
                              CLboolean blockingWrite,
                              optional WebCLEvent[]? eventWaitList,
                              optional WebCLEvent? event);

  void enqueueWriteBufferRect(WebCLRegion dstBuffer,
                              HTMLImageElement srcCanvas,
                              WebCLRegion srcRegion,
                              CLboolean blockingWrite,
                              optional WebCLEvent[]? eventWaitList,
                              optional WebCLEvent? event);

  //////////////////////////////////////////////////////////////////////
  //
  // Writing to WebCLImage
  //

  void enqueueWriteImage(WebCLRegion dstImage,
                         ImageData srcPixels,
                         CLboolean blockingWrite,
                         optional WebCLEvent[]? eventWaitList,
                         optional WebCLEvent? event);

  void enqueueWriteImage(WebCLRegion dstImage,
                         HTMLCanvasElement srcCanvas,
                         CLboolean blockingWrite,
                         optional WebCLEvent[]? eventWaitList,
                         optional WebCLEvent? event);

  void enqueueWriteImage(WebCLRegion dstImage,
                         HTMLImageElement srcImage,
                         CLboolean blockingWrite,
                         optional WebCLEvent[]? eventWaitList,
                         optional WebCLEvent? event);

  void enqueueWriteImage(WebCLRegion dstImage,
                         HTMLVideoElement srcVideo,
                         CLboolean blockingWrite,
                         optional WebCLEvent[]? eventWaitList,
                         optional WebCLEvent? event);

  //////////////////////////////////////////////////////////////////////
  //
  // Reading from WebCL
  //

  void enqueueReadBuffer(WebCLRegion srcBuffer,
                         HTMLCanvasElement dstCanvas,
                         CLboolean blockingRead,
                         optional WebCLEvent[]? eventWaitList,
                         optional WebCLEvent? event);

  void enqueueReadBufferRect(WebCLRegion srcBuffer,
                             HTMLCanvasElement dstCanvas,
                             WebCLRegion dstCanvasRegion,
                             CLboolean blockingRead,
                             optional WebCLEvent[]? eventWaitList,
                             optional WebCLEvent? event);

  void enqueueReadImage(WebCLRegion srcImage,
                        HTMLCanvasElement dstCanvas,
                        CLboolean blockingRead,
                        optional WebCLEvent[]? eventWaitList,
                        optional WebCLEvent? event);
};
</pre>

</div> <!-- strawman -->

<!-- ======================================================================================================= -->

    <h2> <a id="WEBCL_OPENCL_DIFF">Differences between WebCL and OpenCL 1.1</a></h2>

    <p>
      This section describes changes made to the WebCL API and the
      kernel programming language, relative to OpenCL 1.1 Embedded
      Profile.  The main differences are as follows:
    </p>

    <ul>
      <li>2D image support is required</li>
      <li>3D images are not supported</li>
      <li>WebGL interoperability is supported (optionally)</li>
      <li>Structures are not supported as kernel arguments</li>
      <li>Mapping of CL memory objects into host memory space is not supported</li>
      <li>`enqueueWaitForEvents` is folded into `enqueueMarker`/`enqueueBarrier` as in OpenCL 1.2</li>
    </ul>

    <p>
      To promote application portability, WebCL not only defines a
      certain set of minimum capabilities that the platform must
      provide, but also hides certain query properties that would
      often be misused to target an application for specific hardware
      and software configurations. The baseline capabilities and the
      hidden properties are listed in the tables below.
    </p>

    <p>
      <table id="getPlatformInfoEnums">
        <tr><th>Platform Info: clGetPlatformInfo Parameter</th><th>OpenCL 1.1 Embedded Profile</th><th>WebCL</th></tr>

        <tr><td>CL_PLATFORM_PROFILE</td><td>"EMBEDDED_PROFILE"</td><td>"WEBCL_PROFILE"</td></tr>
        <tr><td>CL_PLATFORM_VERSION</td><td>"OpenCL 1.1" + optional vendor string</td><td>"WebCL 1.0"</td></tr>
        <tr><td>CL_PLATFORM_NAME</td><td>Not Specified</td><td>Not Visible</td></tr>
        <tr><td>CL_PLATFORM_VENDOR</td><td>Not Specified</td><td>Not Visible</td></tr>
        <tr><td>CL_PLATFORM_EXTENSIONS</td><td>Extension String</td><td>Not Visible</td></tr>
      </table>
    </p>

    <p>
      <table id="getDeviceInfoEnums">
        <tr><th>Device Info: clGetDeviceInfo Parameter</th><th>OpenCL 1.1 Embedded Profile</th><th>WebCL</th></tr>
        <tr><td>CL_DEVICE_TYPE</td><td>CL_DEVICE_TYPE_CPU;
                                       CL_DEVIDE_TYPE_GPU;
                                       CL_DEVICE_TYPE_ACCELERATOR;
                                       CL_DEVICE_TYPE_DEFAULT;
                                       (Or a combination of the above)</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_VENDOR_ID</td><td>Not Specified</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_MAX_COMPUTE_UNITS</td><td> &gt;=1 </td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS</td><td> &gt;=3 </td><td> &gt;=3 </td></tr>
        <tr><td>CL_DEVICE_MAX_WORK_ITEM_SIZES</td><td>&gt;=(1, 1, 1)</td><td>&gt;=(1, 1, 1)</td></tr>
        <tr><td>CL_DEVICE_MAX_WORK_GROUP_SIZE</td><td>&gt;=1</td><td>&gt;=1</td></tr>
        <tr><td>CL_DEVICE_PREFERRED_VECTOR_WIDTH_* (*=CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, HALF)
                                                    </td><td>cl_uint</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_NATIVE_VECTOR_WIDTH_*</td><td>cl_uint</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_MAX_CLOCK_FREQUENCY</td><td>cl_uint</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_ADDRESS_BITS</td><td>32 or 64 bits</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_MAX_MEM_ALLOC_SIZE</td><td> &gt;= max of CL_DEVICE_GLOBAL_MEM_SIZE/
            4,128, 1024, 1024</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_IMAGE_SUPPORT</td><td>cl_bool</td><td>CL_TRUE</td></tr>
        <tr><td>CL_DEVICE_MAX_READ_IMAGE_ARGS</td><td>&gt;=8 (if image support)</td><td> &gt;=8 </td></tr>
        <tr><td>CL_DEVICE_MAX_WRITE_IMAGE_ARGS</td><td>&gt;=1 (if image support)</td><td> &gt;=1 </td></tr>
        <tr><td>CL_DEVICE_IMAGE2D_MAX_WIDTH</td><td>&gt;=2048 (if image support)</td><td> &gt;=2048 </td></tr>
        <tr><td>CL_DEVICE_IMAGE2D_MAX_HEIGHT</td><td>&gt;=2048 (if image support)</td><td> &gt;=2048 </td></tr>
        <tr><td>CL_DEVICE_IMAGE3D_MAX_WIDTH</td><td>&gt;=2048 (if 3D image support)</td><td>
            No 3D support in WebCL 1.0</td></tr>
        <tr><td>CL_DEVICE_IMAGE3D_MAX_HEIGHT</td><td>&gt;=2048 (if 3D image support)</td><td>
            No 3D support in WebCL 1.0</td></tr>
        <tr><td>CL_DEVICE_IMAGE3D_MAX_DEPTH</td><td>&gt;=2048 (if 3D image support)</td><td>
            No 3D support in WebCL 1.0</td></tr>
        <tr><td>CL_DEVICE_MAX_SAMPLERS</td><td>&gt;=8 (if image support)</td><td>&gt;=8</td></tr>
        <tr><td>CL_DEVICE_MAX_PARAMETER_SIZE</td><td>&gt;=256</td><td>&gt;=256</td></tr>
        <tr><td>CL_DEVICE_MEM_BASE_ADDR_ALIGN</td><td>&gt;= num bits(int16)</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE</td><td>&gt;=sizeof(int16)</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_SINGLE_FP_CONFIG</td><td>CL_FP_ROUND_TO_NEAREST; CL_FP_INF_NAN
            (others optional)</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_GLOBAL_MEM_CACHE_TYPE</td><td>CL_NONE; CL_READ_ONLY_CACHE; CL_READ_WRITE_CACHE
          </td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE</td><td>cl_uint</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_GLOBAL_MEM_CACHE_SIZE</td><td>cl_uint</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_GLOBAL_MEM_SIZE</td><td>cl_uint</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE </td><td>&gt;=1 KB</td><td>&gt;=1</td></tr>
        <tr><td>CL_DEVICE_CONSTANT_ARGS</td><td>&gt;=4</td><td>&gt;=4</td></tr>
        <tr><td>CL_DEVICE_LOCAL_MEM_TYPE</td><td>CL_LOCAL; CL_GLOBAL</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_LOCAL_MEM_SIZE</td><td>&gt;=1 KB</td><td>&gt;=1 KB</td></tr>
        <tr><td>CL_DEVICE_ERROR_CORRECTION_SUPPORT</td><td>cl_bool</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_HOST_UNIFIED_MEMORY</td><td>cl_bool</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_PROFILING_TIMER_RESOLUTION</td><td>size_t</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_ENDIAN_LITTLE</td><td>cl_bool</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_AVAILABLE</td><td>cl_bool</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_COMPILER_AVAILABLE</td><td>cl_bool</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_EXECUTION_CAPABILITIES</td><td>CL_EXEC_KERNEL;
                                                         CL_EXEC_NATIVE_KERNEL</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_QUEUE_PROPERTIES</td><td>CL_QUEUE_PROFILING_ENABLE;
                CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE (optional)</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_PLATFORM</td><td>cl_platform_id</td><td>WebCLPlatform Object</td></tr>
        <tr><td>CL_DEVICE_NAME</td><td>Not Specified</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_VENDOR</td><td>Not Specified</td><td>Not Visible</td></tr>
        <tr><td>CL_DRIVER_VERSION</td><td>Version String</td><td>Not Visible</td></tr>
        <tr><td>CL_DEVICE_PROFILE</td><td>"EMBEDDED_PROFILE"</td><td>"WEBCL_PROFILE"</td></tr>
        <tr><td>CL_DEVICE_VERSION</td><td>Version String</td><td>"WebCL 1.0"</td></tr>
        <tr><td>CL_DEVICE_OPENCL_C_VERSION</td><td>Version String</td><td>Visible</td></tr>
        <tr><td>CL_DEVICE_EXTENSIONS</td><td>Extension String</td><td>Visible</td></tr>

      </table>
    </p>

<!-- ======================================================================================================= -->

    <h2>References</h2>

    <h3>Normative references</h3>
    <dl>

        <dt id="refsASCII">[ASCII]</dt>
        <dd><cite>International Standard ISO/IEC 646:1991. Information technology -
            ISO 7-bit coded character set for information interchange</cite>
        </dd>
        <dt id="refsCANVAS">[CANVAS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/html5/the-canvas-element.html">
            HTML5: The Canvas Element</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>
        <dt id="refsCORS">[CORS]</dt>
        <dd><cite><a href="http://www.w3.org/TR/cors/">
            Cross-Origin Resource Sharing</a></cite>,
            A. van Kesteren, July 2010.
        </dd>
        <dt id="refsDOMSTRING">[DOMSTRING]</dt>
        <dd><cite><a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#DOMString">
            Document Object Model Core: The DOMString type</a></cite>,
            World Wide Web Consortium (W3C).
        </dd>
        <dt id="refsGLES20">[GLES20]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf">
            OpenGLÂ® ES Common Profile Specification Version 2.0.25</a></cite>,
            A. Munshi, J. Leech, November 2010.
        </dd>
        <dt id="refsGLES20GLSL">[GLES20GLSL]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">
            The OpenGLÂ® ES Shading Language Version 1.00</a></cite>,
            R. Simpson, May 2009.
        </dd>
        <dt id="refsHTML">[HTML]</dt>
        <dd><cite><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">
            HTML</a></cite>,
            I. Hickson, June 2011.
        </dd>
        <dt id="refsOPENCL">[OPENCL11]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf">
          OpenCL 1.1 Specification</a></cite>,
          A. Munshi, January 2011.
        </dd>
        <dt id="refsREGISTRY">[REGISTRY]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/webcl/extensions/">
            WebCL Extension Registry</a></cite>
        </dd>
        <dt id="refsRFC2119">[RFC2119]</dt>
        <dd><cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>,
            S. Bradner. IETF, March 1997.
        </dd>
        <dt id="refsTYPEDARRAYS">[TYPEDARRAYS]</dt>
        <dd><cite><a href="http://www.khronos.org/registry/typedarray/specs/latest/">
            Typed Array Specification: Editor's Draft</a></cite>,
            V. Vukicevic, K. Russell, May 2010.
        </dd>
        <dt id="refsWEBIDL">[WEBIDL]</dt>
        <dd><cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL: W3C Editorâs Draft</a></cite>,
            C. McCormack, September 2009.
        </dd>
        <dt id="refsWEBGL">[WEBGL]</dt>
        <dd><cite><a href="https://www.khronos.org/registry/webgl/specs/1.0/">
          WebGL 1.0 Specification</a></cite>,
          C. Marrin, February 2011.
        </dd>
    </dl>

    <h3>Other references</h3>

<!-- ======================================================================================================= -->

    <h2>Acknowledgments</h2>
    <p>This Working Draft is produced by the Khronos WebCL Working Group.</p>

    <p>
       Special thanks to: ...
    </p>
    <p>
        Additional thanks to: ...
        and the members of the Khronos WebCL Working Group.
 </p>



</body>
</html>
