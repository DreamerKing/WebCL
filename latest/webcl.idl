typedef boolean       CLboolean;
typedef long          CLint;
typedef unsigned long CLuint;
typedef unsigned long CLenum;     // Used for enumerated types, such as WebCL.DEVICE_TYPE_GPU


callback WebCLCallback = void (CLenum status, any userdata);


exception WebCLException : DOMException {
  DOMString name;              // A string representation of the numeric error code, e.g. "INVALID_VALUE"
  DOMString? message;          // An implementation-specific description of what caused the exception
};


interface WebCL {

  // Functions

  WebCLPlatform[] getPlatforms();

  WebCLContext? createContext(optional WebCLContextProperties properties);

  DOMString[] getSupportedExtensions();

  void waitForEvents(WebCLEvent[] eventWaitList);

  void unloadCompiler();

  // Enums

  /* Error Codes */
  CLenum SUCCESS                                  =0;
  CLenum DEVICE_NOT_FOUND                         =-1;
  CLenum DEVICE_NOT_AVAILABLE                     =-2;
  CLenum COMPILER_NOT_AVAILABLE                   =-3;
  CLenum MEM_OBJECT_ALLOCATION_FAILURE            =-4;
  CLenum OUT_OF_RESOURCES                         =-5;
  CLenum OUT_OF_HOST_MEMORY                       =-6;
  CLenum PROFILING_INFO_NOT_AVAILABLE             =-7;
  CLenum MEM_COPY_OVERLAP                         =-8;
  CLenum IMAGE_FORMAT_MISMATCH                    =-9;
  CLenum IMAGE_FORMAT_NOT_SUPPORTED               =-10;
  CLenum BUILD_PROGRAM_FAILURE                    =-11;
  CLenum MAP_FAILURE                              =-12;
  CLenum MISALIGNED_SUB_BUFFER_OFFSET             =-13;
  CLenum EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST =-14;
  CLenum INVALID_VALUE                            =-30;
  CLenum INVALID_DEVICE_TYPE                      =-31;
  CLenum INVALID_PLATFORM                         =-32;
  CLenum INVALID_DEVICE                           =-33;
  CLenum INVALID_CONTEXT                          =-34;
  CLenum INVALID_QUEUE_PROPERTIES                 =-35;
  CLenum INVALID_COMMAND_QUEUE                    =-36;
  CLenum INVALID_HOST_PTR                         =-37;
  CLenum INVALID_MEM_OBJECT                       =-38;
  CLenum INVALID_IMAGE_FORMAT_DESCRIPTOR          =-39;
  CLenum INVALID_IMAGE_SIZE                       =-40;
  CLenum INVALID_SAMPLER                          =-41;
  CLenum INVALID_BINARY                           =-42;
  CLenum INVALID_BUILD_OPTIONS                    =-43;
  CLenum INVALID_PROGRAM                          =-44;
  CLenum INVALID_PROGRAM_EXECUTABLE               =-45;
  CLenum INVALID_KERNEL_NAME                      =-46;
  CLenum INVALID_KERNEL_DEFINITION                =-47;
  CLenum INVALID_KERNEL                           =-48;
  CLenum INVALID_ARG_INDEX                        =-49;
  CLenum INVALID_ARG_VALUE                        =-50;
  CLenum INVALID_ARG_SIZE                         =-51;
  CLenum INVALID_KERNEL_ARGS                      =-52;
  CLenum INVALID_WORK_DIMENSION                   =-53;
  CLenum INVALID_WORK_GROUP_SIZE                  =-54;
  CLenum INVALID_WORK_ITEM_SIZE                   =-55;
  CLenum INVALID_GLOBAL_OFFSET                    =-56;
  CLenum INVALID_EVENT_WAIT_LIST                  =-57;
  CLenum INVALID_EVENT                            =-58;
  CLenum INVALID_OPERATION                        =-59;
  CLenum INVALID_GL_OBJECT                        =-60;
  CLenum INVALID_BUFFER_SIZE                      =-61;
  CLenum INVALID_MIP_LEVEL                        =-62;
  CLenum INVALID_GLOBAL_WORK_SIZE                 =-63;
  CLenum INVALID_PROPERTY                         =-64;

  /* OpenCL Version */
  CLenum VERSION_1_0                              =1;
  CLenum VERSION_1_1                              =1;

  /* cl_bool */
  CLenum FALSE                                    =0;
  CLenum TRUE                                     =1;

  /* cl_platform_info */
  CLenum PLATFORM_PROFILE                         =0x0900;
  CLenum PLATFORM_VERSION                         =0x0901;
  CLenum PLATFORM_NAME                            =0x0902;
  CLenum PLATFORM_VENDOR                          =0x0903;
  CLenum PLATFORM_EXTENSIONS                      =0x0904;

  /* cl_device_type - bitfield */
  CLenum DEVICE_TYPE_DEFAULT                      =(1 << 0);
  CLenum DEVICE_TYPE_CPU                          =(1 << 1);
  CLenum DEVICE_TYPE_GPU                          =(1 << 2);
  CLenum DEVICE_TYPE_ACCELERATOR                  =(1 << 3);
  CLenum DEVICE_TYPE_ALL                          =0xFFFFFFFF;

  /* cl_device_info */
  CLenum DEVICE_TYPE                              =0x1000;
  CLenum DEVICE_VENDOR_ID                         =0x1001;
  CLenum DEVICE_MAX_COMPUTE_UNITS                 =0x1002;
  CLenum DEVICE_MAX_WORK_ITEM_DIMENSIONS          =0x1003;
  CLenum DEVICE_MAX_WORK_GROUP_SIZE               =0x1004;
  CLenum DEVICE_MAX_WORK_ITEM_SIZES               =0x1005;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_CHAR       =0x1006;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_SHORT      =0x1007;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_INT        =0x1008;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_LONG       =0x1009;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT      =0x100A;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE     =0x100B;
  CLenum DEVICE_MAX_CLOCK_FREQUENCY               =0x100C;
  CLenum DEVICE_ADDRESS_BITS                      =0x100D;
  CLenum DEVICE_MAX_READ_IMAGE_ARGS               =0x100E;
  CLenum DEVICE_MAX_WRITE_IMAGE_ARGS              =0x100F;
  CLenum DEVICE_MAX_MEM_ALLOC_SIZE                =0x1010;
  CLenum DEVICE_IMAGE2D_MAX_WIDTH                 =0x1011;
  CLenum DEVICE_IMAGE2D_MAX_HEIGHT                =0x1012;
  CLenum DEVICE_IMAGE_SUPPORT                     =0x1016;
  CLenum DEVICE_MAX_PARAMETER_SIZE                =0x1017;
  CLenum DEVICE_MAX_SAMPLERS                      =0x1018;
  CLenum DEVICE_MEM_BASE_ADDR_ALIGN               =0x1019;
  CLenum DEVICE_MIN_DATA_TYPE_ALIGN_SIZE          =0x101A;
  CLenum DEVICE_SINGLE_FP_CONFIG                  =0x101B;
  CLenum DEVICE_GLOBAL_MEM_CACHE_TYPE             =0x101C;
  CLenum DEVICE_GLOBAL_MEM_CACHELINE_SIZE         =0x101D;
  CLenum DEVICE_GLOBAL_MEM_CACHE_SIZE             =0x101E;
  CLenum DEVICE_GLOBAL_MEM_SIZE                   =0x101F;
  CLenum DEVICE_MAX_CONSTANT_BUFFER_SIZE          =0x1020;
  CLenum DEVICE_MAX_CONSTANT_ARGS                 =0x1021;
  CLenum DEVICE_LOCAL_MEM_TYPE                    =0x1022;
  CLenum DEVICE_LOCAL_MEM_SIZE                    =0x1023;
  CLenum DEVICE_ERROR_CORRECTION_SUPPORT          =0x1024;
  CLenum DEVICE_PROFILING_TIMER_RESOLUTION        =0x1025;
  CLenum DEVICE_ENDIAN_LITTLE                     =0x1026;
  CLenum DEVICE_AVAILABLE                         =0x1027;
  CLenum DEVICE_COMPILER_AVAILABLE                =0x1028;
  CLenum DEVICE_EXECUTION_CAPABILITIES            =0x1029;
  CLenum DEVICE_QUEUE_PROPERTIES                  =0x102A;
  CLenum DEVICE_NAME                              =0x102B;
  CLenum DEVICE_VENDOR                            =0x102C;
  CLenum DRIVER_VERSION                           =0x102D;
  CLenum DEVICE_PROFILE                           =0x102E;
  CLenum DEVICE_VERSION                           =0x102F;
  CLenum DEVICE_EXTENSIONS                        =0x1030;
  CLenum DEVICE_PLATFORM                          =0x1031;
  CLenum DEVICE_DOUBLE_FP_CONFIG                  =0x1032;
  CLenum DEVICE_HALF_FP_CONFIG                    =0x1033;
  CLenum DEVICE_PREFERRED_VECTOR_WIDTH_HALF       =0x1034;
  CLenum DEVICE_HOST_UNIFIED_MEMORY               =0x1035;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_CHAR          =0x1036;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_SHORT         =0x1037;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_INT           =0x1038;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_LONG          =0x1039;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_FLOAT         =0x103A;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE        =0x103B;
  CLenum DEVICE_NATIVE_VECTOR_WIDTH_HALF          =0x103C;
  CLenum DEVICE_OPENCL_C_VERSION                  =0x103D;

  /* cl_device_fp_config - bitfield */
  CLenum FP_DENORM                                =(1 << 0);
  CLenum FP_INF_NAN                               =(1 << 1);
  CLenum FP_ROUND_TO_NEAREST                      =(1 << 2);
  CLenum FP_ROUND_TO_ZERO                         =(1 << 3);
  CLenum FP_ROUND_TO_INF                          =(1 << 4);
  CLenum FP_FMA                                   =(1 << 5);
  CLenum FP_SOFT_FLOAT                            =(1 << 6);

  /* cl_device_mem_cache_type */
  CLenum NONE                                     =0x0;
  CLenum READ_ONLY_CACHE                          =0x1;
  CLenum READ_WRITE_CACHE                         =0x2;

  /* cl_device_local_mem_type */
  CLenum LOCAL                                    =0x1;
  CLenum GLOBAL                                   =0x2;

  /* cl_device_exec_capabilities - bitfield */
  CLenum EXEC_KERNEL                              =(1 << 0);
  CLenum EXEC_NATIVE_KERNEL                       =(1 << 1);

  /* cl_command_queue_properties - bitfield */
  CLenum QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE      =(1 << 0);
  CLenum QUEUE_PROFILING_ENABLE                   =(1 << 1);

  /* cl_context_info  */
  CLenum CONTEXT_REFERENCE_COUNT                  =0x1080;
  CLenum CONTEXT_DEVICES                          =0x1081;
  CLenum CONTEXT_PROPERTIES                       =0x1082;
  CLenum CONTEXT_NUM_DEVICES                      =0x1083;

  /* cl_context_info + cl_context_properties */
  CLenum CONTEXT_PLATFORM                         =0x1084;

  /* cl_command_queue_info */
  CLenum QUEUE_CONTEXT                            =0x1090;
  CLenum QUEUE_DEVICE                             =0x1091;
  CLenum QUEUE_REFERENCE_COUNT                    =0x1092;
  CLenum QUEUE_PROPERTIES                         =0x1093;

  /* cl_mem_flags - bitfield */
  CLenum MEM_READ_WRITE                           =(1 << 0);
  CLenum MEM_WRITE_ONLY                           =(1 << 1);
  CLenum MEM_READ_ONLY                            =(1 << 2);

  /* cl_channel_order */
  CLenum R                                        =0x10B0;
  CLenum A                                        =0x10B1;
  CLenum RG                                       =0x10B2;
  CLenum RA                                       =0x10B3;
  CLenum RGB                                      =0x10B4;
  CLenum RGBA                                     =0x10B5;
  CLenum BGRA                                     =0x10B6;
  CLenum ARGB                                     =0x10B7;
  CLenum INTENSITY                                =0x10B8;
  CLenum LUMINANCE                                =0x10B9;
  CLenum Rx                                       =0x10BA;
  CLenum RGx                                      =0x10BB;
  CLenum RGBx                                     =0x10BC;

  /* cl_channel_type */
  CLenum SNORM_INT8                               =0x10D0;
  CLenum SNORM_INT16                              =0x10D1;
  CLenum UNORM_INT8                               =0x10D2;
  CLenum UNORM_INT16                              =0x10D3;
  CLenum UNORM_SHORT_565                          =0x10D4;
  CLenum UNORM_SHORT_555                          =0x10D5;
  CLenum UNORM_INT_101010                         =0x10D6;
  CLenum SIGNED_INT8                              =0x10D7;
  CLenum SIGNED_INT16                             =0x10D8;
  CLenum SIGNED_INT32                             =0x10D9;
  CLenum UNSIGNED_INT8                            =0x10DA;
  CLenum UNSIGNED_INT16                           =0x10DB;
  CLenum UNSIGNED_INT32                           =0x10DC;
  CLenum HALF_FLOAT                               =0x10DD;
  CLenum FLOAT                                    =0x10DE;

  /* cl_mem_object_type */
  CLenum MEM_OBJECT_BUFFER                        =0x10F0;
  CLenum MEM_OBJECT_IMAGE2D                       =0x10F1;

  /* cl_mem_info */
  CLenum MEM_TYPE                                 =0x1100;
  CLenum MEM_FLAGS                                =0x1101;
  CLenum MEM_SIZE                                 =0x1102;
  CLenum MEM_HOST_PTR                             =0x1103;
  CLenum MEM_MAP_COUNT                            =0x1104;
  CLenum MEM_REFERENCE_COUNT                      =0x1105;
  CLenum MEM_CONTEXT                              =0x1106;
  CLenum MEM_ASSOCIATED_MEMOBJECT                 =0x1107;
  CLenum MEM_OFFSET                               =0x1108;

  /* cl_image_info */
  CLenum IMAGE_FORMAT                             =0x1110;
  CLenum IMAGE_ELEMENT_SIZE                       =0x1111;
  CLenum IMAGE_ROW_PITCH                          =0x1112;
  CLenum IMAGE_WIDTH                              =0x1114;
  CLenum IMAGE_HEIGHT                             =0x1115;

  /* cl_addressing_mode */
  CLenum ADDRESS_NONE                             =0x1130;
  CLenum ADDRESS_CLAMP_TO_EDGE                    =0x1131;
  CLenum ADDRESS_CLAMP                            =0x1132;
  CLenum ADDRESS_REPEAT                           =0x1133;
  CLenum ADDRESS_MIRRORED_REPEAT                  =0x1134;

  /* cl_filter_mode */
  CLenum FILTER_NEAREST                           =0x1140;
  CLenum FILTER_LINEAR                            =0x1141;

  /* cl_sampler_info */
  CLenum SAMPLER_REFERENCE_COUNT                  =0x1150;
  CLenum SAMPLER_CONTEXT                          =0x1151;
  CLenum SAMPLER_NORMALIZED_COORDS                =0x1152;
  CLenum SAMPLER_ADDRESSING_MODE                  =0x1153;
  CLenum SAMPLER_FILTER_MODE                      =0x1154;

  /* cl_map_flags - bitfield */
  CLenum MAP_READ                                 =(1 << 0);
  CLenum MAP_WRITE                                =(1 << 1);

  /* cl_program_info */
  CLenum PROGRAM_REFERENCE_COUNT                  =0x1160;
  CLenum PROGRAM_CONTEXT                          =0x1161;
  CLenum PROGRAM_NUM_DEVICES                      =0x1162;
  CLenum PROGRAM_DEVICES                          =0x1163;
  CLenum PROGRAM_SOURCE                           =0x1164;
  CLenum PROGRAM_BINARY_SIZES                     =0x1165;
  CLenum PROGRAM_BINARIES                         =0x1166;

  /* cl_program_build_info */
  CLenum PROGRAM_BUILD_STATUS                     =0x1181;
  CLenum PROGRAM_BUILD_OPTIONS                    =0x1182;
  CLenum PROGRAM_BUILD_LOG                        =0x1183;

  /* cl_build_status */
  CLenum BUILD_SUCCESS                             =0;
  CLenum BUILD_NONE                                =1;
  CLenum BUILD_ERROR                              =-2;
  CLenum BUILD_IN_PROGRESS                        =-3;

  /* cl_kernel_info */
  CLenum KERNEL_FUNCTION_NAME                     =0x1190;
  CLenum KERNEL_NUM_ARGS                          =0x1191;
  CLenum KERNEL_REFERENCE_COUNT                   =0x1192;
  CLenum KERNEL_CONTEXT                           =0x1193;
  CLenum KERNEL_PROGRAM                           =0x1194;

  /* cl_kernel_work_group_info */
  CLenum KERNEL_WORK_GROUP_SIZE                   =0x11B0;
  CLenum KERNEL_COMPILE_WORK_GROUP_SIZE           =0x11B1;
  CLenum KERNEL_LOCAL_MEM_SIZE                    =0x11B2;
  CLenum KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE =0x11B3;
  CLenum KERNEL_PRIVATE_MEM_SIZE                  =0x11B4;

  /* cl_event_info  */
  CLenum EVENT_COMMAND_QUEUE                      =0x11D0;
  CLenum EVENT_COMMAND_TYPE                       =0x11D1;
  CLenum EVENT_REFERENCE_COUNT                    =0x11D2;
  CLenum EVENT_COMMAND_EXECUTION_STATUS           =0x11D3;
  CLenum EVENT_CONTEXT                            =0x11D4;

  /* cl_command_type */
  CLenum COMMAND_NDRANGE_KERNEL                   =0x11F0;
  CLenum COMMAND_TASK                             =0x11F1;
  CLenum COMMAND_NATIVE_KERNEL                    =0x11F2;
  CLenum COMMAND_READ_BUFFER                      =0x11F3;
  CLenum COMMAND_WRITE_BUFFER                     =0x11F4;
  CLenum COMMAND_COPY_BUFFER                      =0x11F5;
  CLenum COMMAND_READ_IMAGE                       =0x11F6;
  CLenum COMMAND_WRITE_IMAGE                      =0x11F7;
  CLenum COMMAND_COPY_IMAGE                       =0x11F8;
  CLenum COMMAND_COPY_IMAGE_TO_BUFFER             =0x11F9;
  CLenum COMMAND_COPY_BUFFER_TO_IMAGE             =0x11FA;
  CLenum COMMAND_MAP_BUFFER                       =0x11FB;
  CLenum COMMAND_MAP_IMAGE                        =0x11FC;
  CLenum COMMAND_UNMAP_MEM_OBJECT                 =0x11FD;
  CLenum COMMAND_MARKER                           =0x11FE;
  CLenum COMMAND_ACQUIRE_GL_OBJECTS               =0x11FF;
  CLenum COMMAND_RELEASE_GL_OBJECTS               =0x1200;
  CLenum COMMAND_READ_BUFFER_RECT                 =0x1201;
  CLenum COMMAND_WRITE_BUFFER_RECT                =0x1202;
  CLenum COMMAND_COPY_BUFFER_RECT                 =0x1203;
  CLenum COMMAND_USER                             =0x1204;

  /* command execution status */
  CLenum COMPLETE                                 =0x0;
  CLenum RUNNING                                  =0x1;
  CLenum SUBMITTED                                =0x2;
  CLenum QUEUED                                   =0x3;
  
  /* cl_buffer_create_type  */
  CLenum BUFFER_CREATE_TYPE_REGION                =0x1220;

  /* cl_profiling_info  */
  CLenum PROFILING_COMMAND_QUEUED                 =0x1280;
  CLenum PROFILING_COMMAND_SUBMIT                 =0x1281;
  CLenum PROFILING_COMMAND_START                  =0x1282;
  CLenum PROFILING_COMMAND_END                    =0x1283;
}


dictionary WebCLContextProperties {
  WebCLPlatform? platform = null;                  // Default: let the implementation decide
  WebCLDevice[]? devices = null;                   // Default: let the implementation decide
  CLenum deviceType = WebCL.DEVICE_TYPE_DEFAULT;   // Default: let the implementation decide
  any shareGroup = null;
}


interface WebCLPlatform {
  object getInfo(CLenum name);
  WebCLDevice[] getDevices(CLenum deviceType);
  DOMString[] getSupportedExtensions();  
}


interface WebCLDevice {
    any getInfo(CLenum name);
    object getExtension(DOMString extensionName);
    DOMString[] getSupportedExtensions();
}


interface WebCLContext {

    WebCLBuffer createBuffer(CLenum memFlags, CLuint sizeInBytes, optional ArrayBuffer srcBuffer);

    WebCLCommandQueue createCommandQueue(optional WebCLDevice? device = null, optional CLenum properties = 0);

    WebCLBuffer createFromGLBuffer(CLenum memFlags, WebGLBuffer buffer);

    WebCLImage createFromGLRenderBuffer(CLenum memFlags, WebGLRenderbuffer renderbuffer);

    WebCLImage createFromGLTexture2D(CLenum memFlags, GLenum textureTarget, 
                                      GLint miplevel, WebGLTexture texture);

    WebCLImage createImage(CLenum memFlags, 
                           WebCLImageDescriptor descriptor,
                           optional ArrayBuffer srcBuffer);

    WebCLProgram createProgram(DOMString source);

    WebCLSampler createSampler(CLboolean normalizedCoords,
                               CLenum addressingMode,
                               CLenum filterMode);

    WebCLEvent createUserEvent();

    any getInfo(CLenum name);

    WebCLImageDescriptor[] getSupportedImageFormats(CLenum memFlags,
                                                    CLenum imageType);


dictionary WebCLImageDescriptor {
  CLenum channelOrder = WebCL.RGBA;        // Default: RGB colors + alpha
  CLenum channelType = WebCL.UNORM_INT8;   // Default: 8-bit unsigned colors normalized to [0, 1]
  CLuint[2] size = [ 1, 1 ];
  CLuint pitch = 0;
}


interface WebCLCommandQueue {

  ////////////////////////////////////////////////////////////////////////////
  //
  // Copying: Buffer <-> Buffer, Image <-> Image, Buffer <-> Image
  //

  void enqueueCopyBuffer(WebCLRegion srcBuffer,
                         WebCLRegion dstBuffer,
                         optional WebCLEvent[]? eventWaitList = null,
                         optional WebCLEvent? event = null);

  void enqueueCopyImage(WebCLRegion srcImage,
                        WebCLRegion dstImage, 
                        optional WebCLEvent[]? eventWaitList = null,
                        optional WebCLEvent? event = null);
  
  void enqueueCopyBufferToImage(WebCLRegion srcBuffer,
                                WebCLRegion dstImage, 
                                optional WebCLEvent[]? eventWaitList = null,
                                optional WebCLEvent? event = null);
  
  void enqueueCopyImageToBuffer(WebCLRegion srcImage,
                                WebCLRegion dstBuffer, 
                                optional WebCLEvent[]? eventWaitList = null,
                                optional WebCLEvent? event = null);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Reading: Buffer -> Host, Image -> Host
  //

  void enqueueReadBuffer(WebCLRegion srcBuffer, 
                         ArrayBuffer dstArray,
                         CLboolean blockingRead, 
                         optional WebCLEvent[]? eventWaitList = null,
                         optional WebCLEvent? event = null);
 
  void enqueueReadImage(WebCLRegion srcImage,
                        ArrayBuffer dstArray,
                        CLboolean blockingRead,
                        optional WebCLEvent[]? eventWaitList = null,
                        optional WebCLEvent? event = null);
  
  void enqueueReadBufferRect(WebCLRegion srcBuffer,
                             ArrayBuffer dstArray,
                             WebCLRegion dstArrayRegion,
                             CLboolean blockingRead,
                             optional WebCLEvent[]? eventWaitList = null,
                             optional WebCLEvent? event = null);
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Writing: Host -> Buffer, Host -> Image
  //

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          ArrayBuffer srcArray,
                          CLboolean blockingWrite, 
                          optional WebCLEvent[]? eventWaitList = null, 
                          optional WebCLEvent? event = null)

  void enqueueWriteImage(WebCLRegion dstImage,
                         ArrayBuffer srcArray, 
                         CLboolean blockingWrite, 
                         optional WebCLEvent[]? eventWaitList = null, 
                         optional WebCLEvent? event = null)

  void enqueueWriteBufferRect(WebCLRegion dstBuffer, 
                              ArrayBuffer srcArray,
                              WebCLRegion srcArrayRegion,
                              CLboolean blockingWrite, 
                              optional WebCLEvent[]? eventWaitList = null,
                              optional WebCLEvent? event = null);
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Acquiring and releasing WebGL objects
  //

  void enqueueAcquireGLObjects(WebCLMemoryObject[] memObjects,
                               optional WebCLEvent[]? eventWaitList = null,
                               optional CLboolean generateEvent = false);
 
  void enqueueReleaseGLObjects(WebCLMemoryObject[] memObjects,
                               optional WebCLEvent[]? eventWaitList = null,
                               optional WebCLEvent? event = null);
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Executing kernels
  //

  void enqueueNDRangeKernel(WebCLKernel kernel, 
                            CLuint[3]? offsets, CLuint[3]? globals, CLuint[3]? locals, 
                            optional WebCLEvent[]? eventWaitList = null,
                            optional WebCLEvent? event = null);
  
  void enqueueTask(WebCLKernel kernel, 
                   optional WebCLEvent[]? eventWaitList = null,
                   optional WebCLEvent? event = null);
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Synchronization
  //

  void enqueueMarker(optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null);

  void enqueueBarrier(optional WebCLEvent[]? eventWaitList = null, optional WebCLEvent? event = null);
  
  void finish();
  
  void flush();

  ////////////////////////////////////////////////////////////////////////////
  //
  // Querying command queue information
  //

  any getInfo(CLenum name);
}


dictionary WebCLRegion {
  WebCLMemoryObject? buffer = null;
  CLuint[3] origin = [0, 0, 0];       // 3rd element applies to 3D buffers only
  CLuint[3] size = [1, 1, 1];         // 3rd element applies to 3D buffers only
  CLuint[2] pitch = [0, 0];           // 2nd element applies to 3D buffers only
}


interface WebCLMemoryObject {
  any getInfo(CLenum name);
  WebCLGLObjectInfo getGLObjectInfo();
}


dictionary WebCLGLObjectInfo {
  CLenum type;   // type of GL object attached to this memory object
  any glObject;  // The GL object used to create this memory object
}


interface WebCLBuffer : WebCLMemoryObject {
  WebCLBuffer createSubBuffer(CLenum flags, CLuint origin, CLuint size);
}


interface WebCLImage : WebCLMemoryObject {
  WebCLImageDescriptor getInfo();
  GLint getGLtextureInfo(CLenum paramName);
}


interface WebCLSampler {
    any getInfo(CLenum name);
}


interface WebCLProgram {
    any getInfo(CLenum name);

    any getBuildInfo(WebCLDevice device, CLenum name);

    void build(WebCLDevice[] devices, 
               DOMString? options, 
               optional WebCLCallback whenFinished,
               optional any userdata);

    WebCLKernel createKernel(DOMString kernelName);

    WebCLKernel[] createKernelsInProgram();
}


interface WebCLKernel {
    any getInfo(CLenum name);
    any getWorkGroupInfo(WebCLDevice device, CLenum name);
    void setArg(CLuint index, any value, optional CLtype type);
}


interface WebCLKernelArgumentTypes {

  typedef unsigned long CLtype;

  // Scalar types; may be bitwise-OR'ed with a vector type

  const CLtype CHAR = 0;
  const CLtype UCHAR = 1;
  const CLtype SHORT = 2;
  const CLtype USHORT = 3;
  const CLtype INT = 4;
  const CLtype UINT = 5;
  const CLtype LONG = 6;
  const CLtype ULONG = 7;
  const CLtype FLOAT = 8;
  const CLtype HALF = 9;      // not supported in all implementations
  const CLtype DOUBLE = 10;   // not supported in all implementations

  // Vector types; must be bitwise-OR'ed with a scalar type

  const CLtype VEC2 = (1 << 16);
  const CLtype VEC3 = (1 << 17);
  const CLtype VEC4 = (1 << 18);
  const CLtype VEC8 = (1 << 19);
  const CLtype VEC16 = (1 << 20);

  // Special types; must not be bitwise-OR'ed with any other type

  const CLtype LOCAL_MEMORY_SIZE = 255;
}


interface WebCLEvent {
    any getInfo(CLenum name);
    any getProfilingInfo(CLenum name);
    void setUserEventStatus(CLenum executionStatus);
    void setCallback(CLenum executionStatus, WebCLCallback notify, optional any userdata);
}


partial interface WebCLContext {
  WebCLBuffer createBuffer(CLenum memFlags, ImageData srcPixels);
  WebCLBuffer createBuffer(CLenum memFlags, HTMLCanvasElement srcCanvas);
  WebCLBuffer createImage(CLenum memFlags, HTMLImageElement srcImage);
  WebCLImage createImage(CLenum memFlags, ImageData srcPixels);
  WebCLImage createImage(CLenum memFlags, HTMLCanvasElement srcCanvas);
  WebCLImage createImage(CLenum memFlags, HTMLImageElement srcImage);
}


partial interface WebCLContext {
  WebCLImage createImage(CLenum memFlags, HTMLVideoElement srcVideo);
}


dictionary WebCLVideoDescriptor : WebCLImageDescriptor {
  CLint framesPerSecond = -1;         // video frame rate, -1 if unknown
  CLint currentEnqueuedFrame = -1:    // -1, 0 to totalFrames-1
  CLint totalFrames = -1;             // -1 if unknown or “live” / streaming	
}


partial interface WebCLCommandQueue {

  //////////////////////////////////////////////////////////////////////
  //
  // Writing to WebCLBuffer
  //

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          ImageData srcPixels,
                          CLboolean blockingWrite,
                          optional WebCLEvent[]? eventWaitList = null, 
                          optional WebCLEvent? event = null);

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          HTMLCanvasElement srcCanvas,
                          CLboolean blockingWrite,
                          optional WebCLEvent[]? eventWaitList = null, 
                          optional WebCLEvent? event = null);

  void enqueueWriteBuffer(WebCLRegion dstBuffer,
                          HTMLImageElement srcImage,
                          CLboolean blockingWrite,
                          optional WebCLEvent[]? eventWaitList = null, 
                          optional WebCLEvent? event = null);

  void enqueueWriteBufferRect(WebCLRegion dstBuffer, 
                              ImageData srcPixels,
                              WebCLRegion srcRegion,
                              CLboolean blockingWrite, 
                              optional WebCLEvent[]? eventWaitList = null,
                              optional WebCLEvent? event = null);

  void enqueueWriteBufferRect(WebCLRegion dstBuffer, 
                              HTMLCanvasElement srcCanvas,
                              WebCLRegion srcRegion,
                              CLboolean blockingWrite, 
                              optional WebCLEvent[]? eventWaitList = null,
                              optional WebCLEvent? event = null);

  void enqueueWriteBufferRect(WebCLRegion dstBuffer, 
                              HTMLImageElement srcCanvas,
                              WebCLRegion srcRegion,
                              CLboolean blockingWrite, 
                              optional WebCLEvent[]? eventWaitList = null,
                              optional WebCLEvent? event = null);

  //////////////////////////////////////////////////////////////////////
  //
  // Writing to WebCLImage
  //

  void enqueueWriteImage(WebCLRegion dstImage,
                         ImageData srcPixels,
                         CLboolean blockingWrite, 
                         optional WebCLEvent[]? eventWaitList = null, 
                         optional WebCLEvent? event = null);

  void enqueueWriteImage(WebCLRegion dstImage,
                         HTMLCanvasElement srcCanvas,
                         CLboolean blockingWrite, 
                         optional WebCLEvent[]? eventWaitList = null, 
                         optional WebCLEvent? event = null);

  void enqueueWriteImage(WebCLRegion dstImage,
                         HTMLImageElement srcImage,
                         CLboolean blockingWrite, 
                         optional WebCLEvent[]? eventWaitList = null, 
                         optional WebCLEvent? event = null);

  void enqueueWriteImage(WebCLRegion dstImage,
                         HTMLVideoElement srcVideo,
                         CLboolean blockingWrite, 
                         optional WebCLEvent[]? eventWaitList = null, 
                         optional WebCLEvent? event = null);

  //////////////////////////////////////////////////////////////////////
  //
  // Reading from WebCL
  //

  void enqueueReadBuffer(WebCLRegion srcBuffer,
                         HTMLCanvasElement dstCanvas,
                         CLboolean blockingRead,
                         optional WebCLEvent[]? eventWaitList = null,
                         optional WebCLEvent? event = null);

  void enqueueReadBufferRect(WebCLRegion srcBuffer,
                             HTMLCanvasElement dstCanvas,
                             WebCLRegion dstCanvasRegion,
                             CLboolean blockingRead, 
                             optional WebCLEvent[]? eventWaitList = null,
                             optional WebCLEvent? event = null);

  void enqueueReadImage(WebCLRegion srcImage,
                        HTMLCanvasElement dstCanvas,
                        CLboolean blockingRead,
                        optional WebCLEvent[]? eventWaitList = null,
                        optional WebCLEvent? event = null);
}
